{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Seos Mobile SDK for Android Overview New to the SDK? Go to the getting started section This document is a quick start guide to integrating Mobile Credentials in an application using the ASSA ABLOY Seos Mobile SDK for Android version 6.x. It explains some of the basic uses of the SDK, and contains a few code samples to get started. The SDK is divided into three main areas: Seos TSM integration. Handles installation and configuration of Seos, issuing and revocation of keys, etc. Interaction with the installed Seos instance. Listing keys, reading key data, etc. Communication with readers, either over Bluetooth or HCE. The Seos eco system is rather complex, and the SDK is constantly evolving. Depending on the type of TSM used by the backend, the type of phone and the type of secure element, the underlying process of installing and managing Seos might differ. The goal of the SDK is to hide that complexity from the integrator and provide a uniform API independent of the underlying implementation. Third party licenses Library License Bouncy Castle https://www.bouncycastle.org/license.html Gson http://www.apache.org/licenses/LICENSE-2.0 SLF4J http://www.slf4j.org/license.html OkHttp http://www.apache.org/licenses/LICENSE-2.0 Mixpanel https://github.com/mixpanel/mixpanel-android/blob/master/LICENSE","title":"Home"},{"location":"index.html#seos-mobile-sdk-for-android-overview","text":"New to the SDK? Go to the getting started section This document is a quick start guide to integrating Mobile Credentials in an application using the ASSA ABLOY Seos Mobile SDK for Android version 6.x. It explains some of the basic uses of the SDK, and contains a few code samples to get started. The SDK is divided into three main areas: Seos TSM integration. Handles installation and configuration of Seos, issuing and revocation of keys, etc. Interaction with the installed Seos instance. Listing keys, reading key data, etc. Communication with readers, either over Bluetooth or HCE. The Seos eco system is rather complex, and the SDK is constantly evolving. Depending on the type of TSM used by the backend, the type of phone and the type of secure element, the underlying process of installing and managing Seos might differ. The goal of the SDK is to hide that complexity from the integrator and provide a uniform API independent of the underlying implementation.","title":"Seos Mobile SDK for Android Overview"},{"location":"index.html#third-party-licenses","text":"Library License Bouncy Castle https://www.bouncycastle.org/license.html Gson http://www.apache.org/licenses/LICENSE-2.0 SLF4J http://www.slf4j.org/license.html OkHttp http://www.apache.org/licenses/LICENSE-2.0 Mixpanel https://github.com/mixpanel/mixpanel-android/blob/master/LICENSE","title":"Third party licenses"},{"location":"api-changes/migrating-3-4.html","text":"Migrating from 3.x The main difference between 3.x and 4.x is improved error handling. The number of error codes given from the API has been reduced and a few new ones have been added. See the javadoc for more information on the meaning of, and how to handle, the different error codes. BLE OpeningStatus codes has been updated to clarify and simplify. Apart from the changes new features have been introduced, e.g. support for the Bluetooth LE reader seamless mode and optimizations for Android 5.0.","title":"3.x to 4.0"},{"location":"api-changes/migrating-3-4.html#migrating-from-3x","text":"The main difference between 3.x and 4.x is improved error handling. The number of error codes given from the API has been reduced and a few new ones have been added. See the javadoc for more information on the meaning of, and how to handle, the different error codes. BLE OpeningStatus codes has been updated to clarify and simplify. Apart from the changes new features have been introduced, e.g. support for the Bluetooth LE reader seamless mode and optimizations for Android 5.0.","title":"Migrating from 3.x"},{"location":"api-changes/migrating-4-5.html","text":"Migrating from 4.x There are a few minor changes that will break backward compatability in the BLE integration between 4.x and 5.x. 5.x contains improved possibilities for integrations to extend and customize how the decission is made when to connect to a BLE reader. Where the 4.x API used a list of enum values, to configure what opening modes should be supported, the 5.0 implementation uses a list of classes each implementing a specific opening mode. The SDK provides three opening mode implementations out of the box as descibed in the Bluetooth reader integration chapter: TapOpeningTrigger SeamlessOpeningTrigger TwistAndGoOpeningTrigger The utility method ScanConfiguration.providedOpeningMethods(BleScanService bleScanService) will create a list containing implementations of all opening modes supported by the SDK. Unless you implement your own opening trigger or want to use only a subset of the provided opening modes provided by the SDK, this method should be the preferred way of initializing the list of supported opening modes.","title":"4.x to 5.0"},{"location":"api-changes/migrating-4-5.html#migrating-from-4x","text":"There are a few minor changes that will break backward compatability in the BLE integration between 4.x and 5.x. 5.x contains improved possibilities for integrations to extend and customize how the decission is made when to connect to a BLE reader. Where the 4.x API used a list of enum values, to configure what opening modes should be supported, the 5.0 implementation uses a list of classes each implementing a specific opening mode. The SDK provides three opening mode implementations out of the box as descibed in the Bluetooth reader integration chapter: TapOpeningTrigger SeamlessOpeningTrigger TwistAndGoOpeningTrigger The utility method ScanConfiguration.providedOpeningMethods(BleScanService bleScanService) will create a list containing implementations of all opening modes supported by the SDK. Unless you implement your own opening trigger or want to use only a subset of the provided opening modes provided by the SDK, this method should be the preferred way of initializing the list of supported opening modes.","title":"Migrating from 4.x"},{"location":"api-changes/migrating-5-6.html","text":"Introduction This migration guide aims to ease the process of migrating from the ASSA ABLOY Mobile Keys SDK version 5.x to version 6.0. Much has been done to improve the ASSA ABLOY Mobile Keys SDK integration experience for new integrators. For an integrator already using the SDK this will likely mean removing code and making some minor adoptions. Definitions and abbreviations Expression Description The integrating application The Android Application using the ASSA ABLOY Mobile Services Android SDK. //\u2026 The double slash three dots in code samples indicates that code has been intentionally left out for clarity. Renamed classes Version 5.x Version 6.0 com.assaabloy.mobilekeys.api.SoftAndroidMobileKeysFactory com.assaabloy.mobilekeys.api.MobileKeysApi com.assaabloy.mobilekeys.api.ble.BleOpeningTrigger com.assaabloy.mobilekeys.api.ble.OpeningTrigger com.assaabloy.mobilekeys.api.ble.OpeningResult (OpeningResult now represents the entire opening, see JavaDoc) com.assaabloy.mobilekeys.api.ble.OpeningTriggerAction com.assaabloy.mobilekeys.api.ApiConfiguration.ApiConfigurationBuilder com.assaabloy.mobilekeys.api.ApiConfiguration.Builder com.assaabloy.mobilekeys.api.MobileKeysErrorCode com.assaabloy.mobilekeys.api.MobileKeysApiErrorCode Renamed fields and types Version 5.x Version 6.0 com.assaabloy.mobilekeys.api.ble.OpeningStatus#MOBILE_KEY_NOT_FOUND com.assaabloy.mobilekeys.api.ble.OpeningStatus#REJECTED General changes Build system The SDK is no longer packaged as two separate JAR files but is now packaged as a single Android Archive (AAR). The SDK still has two flavors, one for Release and one Debug. In your build.gradle file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 repositories { //\u2026 flatDir { dirs 'libs' } } dependencies { //\u2026 //aar file from libs dir. Name and version is from the filename. debugCompile ( group: 'com.assaabloy.mobilekeys.api' , name: 'mobilekeys-android-sdk-debug' , version: '6.0' , ext: 'aar' ) releaseCompile ( group: 'com.assaabloy.mobilekeys.api' , name: 'mobilekeys-android-sdk-release' , version: '6.0' , ext: 'aar' ) // Mobile Keys SDK transitive dependencies compile \"com.google.code.gson:gson:2.4\" compile \"org.slf4j:slf4j-api:1.7.21\" compile 'com.mixpanel.android:mixpanel-android:4.8.6@aar' //Enable logging from Mobile Keys SDK debugCompile ( group: 'com.assaabloy.mobilekeys.api' , name: 'android-slf4j' , version: '6.0' ) } The AAR package embeds an AndroidManifest.xml file which contains some basic configuration such as the permissions and the Service declarations. This will automatically be merged into the integrating application's AndroidManifest.xml when building. 6.2 MobileKeys The main entry point for the SDK was previously SoftAndroidMobileKeysFactory . This class has now been renamed to MobileKeysApi. During the initialization process of the MobileKeysApi , aside from an Android Context and a ApiConfiguration , the initialize method now also takes a ScanConfiguration . The ApiConfiguration no longer have a setUseHce method. This configuration has been moved into another class. More on that in the HCE Section \u2003 The interface towards mobile keys have changed slightly. The operations towards the interface should now throw significantly less MobileKeysException s with SDK_BUSY errors when using the synchronous methods listMobileKeys and getEndpointInfo . The wrapping layers of Seos have been removed, i.e. SeosSession and MobileKeysSession , instead the implementing application can obtain and use a Seos Access API session directly. With this change we also removed the password API. For more advanced use cases we now refer to the Seos and Seos Access API documentation. It is now possible to subscribe to changes in the MobileKeys interface using the addListener(MobileKeysListener) method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //... MobileKeys mobileKeys = MobileKeysApi . getInstance (). getMobileKeys (); mobileKeys . addListener ( this ); } @Override public void onMobileKeysChanged ( int change ) { if ( MobileKeysListener . ENDPOINT_INFO == ( change & MobileKeysListener . ENDPOINT_INFO )) { //The EndpointInfo has changed //... } if ( MobileKeysListener . KEYS_CHANGED == ( change & MobileKeysListener . KEYS_CHANGED )) { //The list of Mobile Keys has changed //... } } Device Eligibility The eligibility checking feature has been moved into the MobileKeysApi class for visibility. Error codes The number of error codes included in the MobileKeysException 's has been greatly reduced and now has more clear meaning. Please refer to the Javadoc for MobileKeysApiError code for the description of each error code and the respective recommended action. BLe A big improvement in the new SDK is that the BLe service is bundled in to the SDK. The integrating application should no longer extend the BleScanService class. Don't worry though, the integrating application still have the control over starting and stopping the service and if the SDK should interact with readers or not. Please remove your current BLe service and start using the bundled version instead. Controlling BLe scanning The functionality of the BleScanService is maintained but all of the Android specific code is now inside the SDK and exposed as a separate and condensed interface: ReaderConnectionController . Get an instance of the ReaderConnectionController from the MobileKeysApi class. 1 2 ReaderConnectionController readerConnectionController = MobileKeysApi . getInstance (). getReaderConnectionController (); readerConnectionController . startScanning (); With the ReaderConnectionController you can start and stop scanning for BLe readers which in turn enables and disables the BLe service. Additionally, you can start scanning with the service as a foreground service with the startForegroundScanning(Notification) method. The method getScanConfiguration gives you an instance of the current ScanConfiguration . Changing the properties of the ScanConfiguration using the setter methods will be applied directly to the scanning, some of which will automatically restart the current scanning. Please refer to the Javadoc of the ScanConfiguration regarding this. The ScanConfiguration class now has a builder method for convenience. 1 2 3 ReaderConnectionController readerConnectionController = MobileKeysApi . getInstance (). getReaderConnectionController (); readerConnectionController . getScanConfiguration (). setRssiSensitivity ( RssiSensitivity . LOW ); //the SDK is now scanning with RSSI sensitivity LOW Callbacks Callbacks from the SDK about reader sessions over BLe is now moved into the ReaderConnectionCallback . The ReaderConnectionCallback class can only have one listener, but there is no restriction on how many ReaderConnectionCallback instances that can be created. The callback interface has changed so that a closed connection now reports back an opening result object containing the opening status and additional payload. The payload is an optional application specific message that was returned from the lock. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //... ReaderConnectionCallback readerConnectionCallback = new ReaderConnectionCallback ( getApplicationContext ()); readerConnectionCallback . registerReceiver ( this ); } @Override public void onReaderConnectionOpened ( Reader reader , OpeningType openingType ) { Toast . makeText ( this , \"onReaderConnectionOpened\" , Toast . LENGTH_SHORT ). show (); } @Override public void onReaderConnectionClosed ( Reader reader , OpeningResult openingResult ) { Toast . makeText ( this , \"onReaderConnectionClosed\" , Toast . LENGTH_SHORT ). show (); } //The rest of the ReaderConnectionListener interface OpeningTriggers The behavior of the OpeningTrigger classes has changed slightly. They now have lifecycle methods that better reflect the current state of the BLe scanning. The abstract class ManualOpeningTrigger now also have the helper method getClosestReaderByOpeningType(OpeningType). Each trigger implementation now has the ability to interact with the BleScanner interface through the getBleScanner method to open readers, list readers as well as send callbacks to the registered ReaderConnectionListeners. Be careful though, this object will be null when the service is not running, use the isCreated method to check this. There is also a similar method to check if the SDK is scanning for readers, isStarted. The lifecycle methods are 1 2 3 4 5 onCreate - The service was created . It is safe to call getBleScanner . onDestroy - The service was destroyed . It is no longer safe to call getBleScanner as it will return null . onStart - When the scanning is started . onStop - When the scanning is stopped . The scanning will be started immediately when the service starts and if the Bluetooth is turned on. Additionally, the scanning will be started and stopped during reader sessions and when some properties of the ScanConfiguration changes. \u2003 HCE The HCE service is now bundled in to the SDK and the integrating application should not extend the HceService. Configure the HCE service The service is disabled by default but can be enabled and disabled using the ReaderConnectionController. This replaces the ApiConfiguration.setUseHce functionality. In order to use the HCE service the integrating application need to specify an AID to be used when communicating with readers through HCE. This is achieved by the resource merging mechanism of the android build process. If you browse the Mobile Keys SDK AAR package by looking in the /build/intermediates/exploded-aar/com.assaabloy.mobilekeys.api/ folder in Android Studio, you will notice a file called seos_hce_service.xml in the /res/xml/ directory. Override this file by creating an equal one in the integrating applications /res/xml/ directory (you can copy the file from the SDK). Replace the value in the name attribute of the <aid-filter> tag with an AID provided by your onboarding team. Callbacks Callbacks from the SDK about reader sessions over HCE is now moved into the HceConnectionCallback . The method signatures for the new HceConnectionListener are the same as the ones in the now replaced HceService class . The HceConnectionCallback class can only have one listener, but there is no restriction on how many HceConnectionCallback instances that are created. 1 2 3 4 5 6 7 8 9 10 11 //... HceConnectionCallback hceConnectionCallback = new HceConnectionCallback ( getApplicationContext ()); hceConnectionCallback . registerReceiver ( this ); } @Override public void onHceSessionOpened () { Toast . makeText ( this , \"onSessionOpened\" , Toast . LENGTH_SHORT ). show (); } //The rest of the HceConnectionListener interface Put and get data The Put and get data API have been removed from Mobile Keys SDK but the functionality remains. The API responsible for this now resides in Seos Access API. Accessing the Seos Access API In order to perform the put and get data you need to open a Seos session. Opening a session is made through the Mobile Keys SDK. Note that you might have to have a different set of session parameters in order to establish your session. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //... Session session = null ; try { SessionParameters openParameters = new SessionParameters . Builder () . setSelection ( Select . extendedSelectAdf ( oidFromIdentifier ( identifier )) . setPrivacyKeyset ( new GenesisPrivacyKeyset ()) . build (); session = mobileKeys . openSeosAccessApiSession ( openParameters ); // Use session to put and/or get data } finally // make sure to close the session when you are done { if ( session != null ) { session . close (); } } Put data command To put data you need to obtain a Seos session, you may for instance use the one described previously. Then create and run a put command. Note that you might have different requirements that prevents you from using the session described in Accessing the Seos Access API. The generic data object put command is described below. 1 2 3 4 5 6 7 8 9 10 11 //... Command < Void > putCommand = Commands . putSeosObject ( new DataObject ( new SeosTag ( /*TAG ID*/ ), data )); CommandResult < Void > result = session . execute ( putCommand ); if ( result . status () == CommandResult . Status . SUCCESS ) { // Success } else { // Failure } Get data command To get data you need to obtain a Seos session, you may for instance use the one described previously. Then create and run a get data command. Note that you might have different requirements that prevents you from using the session described in Accessing the Seos Access API. The generic data object get command is described below. 1 2 3 4 5 6 7 8 9 10 11 12 13 //... Command < DataObject > readDataCommand = getSeosObject ( dataObject ( /*depending on what object you want*/ )); CommandResult < DataObject > result = session . execute ( readDataCommand ); if ( result . status () == CommandResult . Status . SUCCESS ) { // Success DataObject dataObject = result . responseData (); } else { // Failure } Get authentication info Authentication info contains the oid last used to authenticate and the authentication counter. In order to get the information, you need to obtain a Seos session and then create and run the specific 'last authentication info' command. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //... Command < AuthenticationInfo > getDataCommand = Commands . getSeosObject ( SeosObjects . LAST_AUTHENTICATION_INFO ); CommandResult < AuthenticationInfo > result = session . execute ( getDataCommand ); if ( result . status () == CommandResult . Status . SUCCESS ) { // Success Oid oid = getDataResult . responseData (). lastAuthenticatedOid (); int counter = getDataResults . responseData (). authenticationCounter () } else { // Failure }","title":"5.x to 6.0"},{"location":"api-changes/migrating-5-6.html#introduction","text":"This migration guide aims to ease the process of migrating from the ASSA ABLOY Mobile Keys SDK version 5.x to version 6.0. Much has been done to improve the ASSA ABLOY Mobile Keys SDK integration experience for new integrators. For an integrator already using the SDK this will likely mean removing code and making some minor adoptions.","title":"Introduction"},{"location":"api-changes/migrating-5-6.html#definitions-and-abbreviations","text":"Expression Description The integrating application The Android Application using the ASSA ABLOY Mobile Services Android SDK. //\u2026 The double slash three dots in code samples indicates that code has been intentionally left out for clarity.","title":"Definitions and abbreviations"},{"location":"api-changes/migrating-5-6.html#renamed-classes","text":"Version 5.x Version 6.0 com.assaabloy.mobilekeys.api.SoftAndroidMobileKeysFactory com.assaabloy.mobilekeys.api.MobileKeysApi com.assaabloy.mobilekeys.api.ble.BleOpeningTrigger com.assaabloy.mobilekeys.api.ble.OpeningTrigger com.assaabloy.mobilekeys.api.ble.OpeningResult (OpeningResult now represents the entire opening, see JavaDoc) com.assaabloy.mobilekeys.api.ble.OpeningTriggerAction com.assaabloy.mobilekeys.api.ApiConfiguration.ApiConfigurationBuilder com.assaabloy.mobilekeys.api.ApiConfiguration.Builder com.assaabloy.mobilekeys.api.MobileKeysErrorCode com.assaabloy.mobilekeys.api.MobileKeysApiErrorCode","title":"Renamed classes"},{"location":"api-changes/migrating-5-6.html#renamed-fields-and-types","text":"Version 5.x Version 6.0 com.assaabloy.mobilekeys.api.ble.OpeningStatus#MOBILE_KEY_NOT_FOUND com.assaabloy.mobilekeys.api.ble.OpeningStatus#REJECTED","title":"Renamed fields and types"},{"location":"api-changes/migrating-5-6.html#general-changes","text":"","title":"General changes"},{"location":"api-changes/migrating-5-6.html#build-system","text":"The SDK is no longer packaged as two separate JAR files but is now packaged as a single Android Archive (AAR). The SDK still has two flavors, one for Release and one Debug. In your build.gradle file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 repositories { //\u2026 flatDir { dirs 'libs' } } dependencies { //\u2026 //aar file from libs dir. Name and version is from the filename. debugCompile ( group: 'com.assaabloy.mobilekeys.api' , name: 'mobilekeys-android-sdk-debug' , version: '6.0' , ext: 'aar' ) releaseCompile ( group: 'com.assaabloy.mobilekeys.api' , name: 'mobilekeys-android-sdk-release' , version: '6.0' , ext: 'aar' ) // Mobile Keys SDK transitive dependencies compile \"com.google.code.gson:gson:2.4\" compile \"org.slf4j:slf4j-api:1.7.21\" compile 'com.mixpanel.android:mixpanel-android:4.8.6@aar' //Enable logging from Mobile Keys SDK debugCompile ( group: 'com.assaabloy.mobilekeys.api' , name: 'android-slf4j' , version: '6.0' ) } The AAR package embeds an AndroidManifest.xml file which contains some basic configuration such as the permissions and the Service declarations. This will automatically be merged into the integrating application's AndroidManifest.xml when building. 6.2 MobileKeys The main entry point for the SDK was previously SoftAndroidMobileKeysFactory . This class has now been renamed to MobileKeysApi. During the initialization process of the MobileKeysApi , aside from an Android Context and a ApiConfiguration , the initialize method now also takes a ScanConfiguration . The ApiConfiguration no longer have a setUseHce method. This configuration has been moved into another class. More on that in the HCE Section \u2003 The interface towards mobile keys have changed slightly. The operations towards the interface should now throw significantly less MobileKeysException s with SDK_BUSY errors when using the synchronous methods listMobileKeys and getEndpointInfo . The wrapping layers of Seos have been removed, i.e. SeosSession and MobileKeysSession , instead the implementing application can obtain and use a Seos Access API session directly. With this change we also removed the password API. For more advanced use cases we now refer to the Seos and Seos Access API documentation. It is now possible to subscribe to changes in the MobileKeys interface using the addListener(MobileKeysListener) method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //... MobileKeys mobileKeys = MobileKeysApi . getInstance (). getMobileKeys (); mobileKeys . addListener ( this ); } @Override public void onMobileKeysChanged ( int change ) { if ( MobileKeysListener . ENDPOINT_INFO == ( change & MobileKeysListener . ENDPOINT_INFO )) { //The EndpointInfo has changed //... } if ( MobileKeysListener . KEYS_CHANGED == ( change & MobileKeysListener . KEYS_CHANGED )) { //The list of Mobile Keys has changed //... } }","title":"Build system"},{"location":"api-changes/migrating-5-6.html#device-eligibility","text":"The eligibility checking feature has been moved into the MobileKeysApi class for visibility.","title":"Device Eligibility"},{"location":"api-changes/migrating-5-6.html#error-codes","text":"The number of error codes included in the MobileKeysException 's has been greatly reduced and now has more clear meaning. Please refer to the Javadoc for MobileKeysApiError code for the description of each error code and the respective recommended action.","title":"Error codes"},{"location":"api-changes/migrating-5-6.html#ble","text":"A big improvement in the new SDK is that the BLe service is bundled in to the SDK. The integrating application should no longer extend the BleScanService class. Don't worry though, the integrating application still have the control over starting and stopping the service and if the SDK should interact with readers or not. Please remove your current BLe service and start using the bundled version instead.","title":"BLe"},{"location":"api-changes/migrating-5-6.html#controlling-ble-scanning","text":"The functionality of the BleScanService is maintained but all of the Android specific code is now inside the SDK and exposed as a separate and condensed interface: ReaderConnectionController . Get an instance of the ReaderConnectionController from the MobileKeysApi class. 1 2 ReaderConnectionController readerConnectionController = MobileKeysApi . getInstance (). getReaderConnectionController (); readerConnectionController . startScanning (); With the ReaderConnectionController you can start and stop scanning for BLe readers which in turn enables and disables the BLe service. Additionally, you can start scanning with the service as a foreground service with the startForegroundScanning(Notification) method. The method getScanConfiguration gives you an instance of the current ScanConfiguration . Changing the properties of the ScanConfiguration using the setter methods will be applied directly to the scanning, some of which will automatically restart the current scanning. Please refer to the Javadoc of the ScanConfiguration regarding this. The ScanConfiguration class now has a builder method for convenience. 1 2 3 ReaderConnectionController readerConnectionController = MobileKeysApi . getInstance (). getReaderConnectionController (); readerConnectionController . getScanConfiguration (). setRssiSensitivity ( RssiSensitivity . LOW ); //the SDK is now scanning with RSSI sensitivity LOW","title":"Controlling BLe scanning"},{"location":"api-changes/migrating-5-6.html#callbacks","text":"Callbacks from the SDK about reader sessions over BLe is now moved into the ReaderConnectionCallback . The ReaderConnectionCallback class can only have one listener, but there is no restriction on how many ReaderConnectionCallback instances that can be created. The callback interface has changed so that a closed connection now reports back an opening result object containing the opening status and additional payload. The payload is an optional application specific message that was returned from the lock. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //... ReaderConnectionCallback readerConnectionCallback = new ReaderConnectionCallback ( getApplicationContext ()); readerConnectionCallback . registerReceiver ( this ); } @Override public void onReaderConnectionOpened ( Reader reader , OpeningType openingType ) { Toast . makeText ( this , \"onReaderConnectionOpened\" , Toast . LENGTH_SHORT ). show (); } @Override public void onReaderConnectionClosed ( Reader reader , OpeningResult openingResult ) { Toast . makeText ( this , \"onReaderConnectionClosed\" , Toast . LENGTH_SHORT ). show (); } //The rest of the ReaderConnectionListener interface","title":"Callbacks"},{"location":"api-changes/migrating-5-6.html#openingtriggers","text":"The behavior of the OpeningTrigger classes has changed slightly. They now have lifecycle methods that better reflect the current state of the BLe scanning. The abstract class ManualOpeningTrigger now also have the helper method getClosestReaderByOpeningType(OpeningType). Each trigger implementation now has the ability to interact with the BleScanner interface through the getBleScanner method to open readers, list readers as well as send callbacks to the registered ReaderConnectionListeners. Be careful though, this object will be null when the service is not running, use the isCreated method to check this. There is also a similar method to check if the SDK is scanning for readers, isStarted. The lifecycle methods are 1 2 3 4 5 onCreate - The service was created . It is safe to call getBleScanner . onDestroy - The service was destroyed . It is no longer safe to call getBleScanner as it will return null . onStart - When the scanning is started . onStop - When the scanning is stopped . The scanning will be started immediately when the service starts and if the Bluetooth is turned on. Additionally, the scanning will be started and stopped during reader sessions and when some properties of the ScanConfiguration changes.","title":"OpeningTriggers"},{"location":"api-changes/migrating-5-6.html#hce","text":"The HCE service is now bundled in to the SDK and the integrating application should not extend the HceService.","title":"HCE"},{"location":"api-changes/migrating-5-6.html#configure-the-hce-service","text":"The service is disabled by default but can be enabled and disabled using the ReaderConnectionController. This replaces the ApiConfiguration.setUseHce functionality. In order to use the HCE service the integrating application need to specify an AID to be used when communicating with readers through HCE. This is achieved by the resource merging mechanism of the android build process. If you browse the Mobile Keys SDK AAR package by looking in the /build/intermediates/exploded-aar/com.assaabloy.mobilekeys.api/ folder in Android Studio, you will notice a file called seos_hce_service.xml in the /res/xml/ directory. Override this file by creating an equal one in the integrating applications /res/xml/ directory (you can copy the file from the SDK). Replace the value in the name attribute of the <aid-filter> tag with an AID provided by your onboarding team.","title":"Configure the HCE service"},{"location":"api-changes/migrating-5-6.html#callbacks_1","text":"Callbacks from the SDK about reader sessions over HCE is now moved into the HceConnectionCallback . The method signatures for the new HceConnectionListener are the same as the ones in the now replaced HceService class . The HceConnectionCallback class can only have one listener, but there is no restriction on how many HceConnectionCallback instances that are created. 1 2 3 4 5 6 7 8 9 10 11 //... HceConnectionCallback hceConnectionCallback = new HceConnectionCallback ( getApplicationContext ()); hceConnectionCallback . registerReceiver ( this ); } @Override public void onHceSessionOpened () { Toast . makeText ( this , \"onSessionOpened\" , Toast . LENGTH_SHORT ). show (); } //The rest of the HceConnectionListener interface","title":"Callbacks"},{"location":"api-changes/migrating-5-6.html#put-and-get-data","text":"The Put and get data API have been removed from Mobile Keys SDK but the functionality remains. The API responsible for this now resides in Seos Access API.","title":"Put and get data"},{"location":"api-changes/migrating-5-6.html#accessing-the-seos-access-api","text":"In order to perform the put and get data you need to open a Seos session. Opening a session is made through the Mobile Keys SDK. Note that you might have to have a different set of session parameters in order to establish your session. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //... Session session = null ; try { SessionParameters openParameters = new SessionParameters . Builder () . setSelection ( Select . extendedSelectAdf ( oidFromIdentifier ( identifier )) . setPrivacyKeyset ( new GenesisPrivacyKeyset ()) . build (); session = mobileKeys . openSeosAccessApiSession ( openParameters ); // Use session to put and/or get data } finally // make sure to close the session when you are done { if ( session != null ) { session . close (); } }","title":"Accessing the Seos Access API"},{"location":"api-changes/migrating-5-6.html#put-data-command","text":"To put data you need to obtain a Seos session, you may for instance use the one described previously. Then create and run a put command. Note that you might have different requirements that prevents you from using the session described in Accessing the Seos Access API. The generic data object put command is described below. 1 2 3 4 5 6 7 8 9 10 11 //... Command < Void > putCommand = Commands . putSeosObject ( new DataObject ( new SeosTag ( /*TAG ID*/ ), data )); CommandResult < Void > result = session . execute ( putCommand ); if ( result . status () == CommandResult . Status . SUCCESS ) { // Success } else { // Failure }","title":"Put data command"},{"location":"api-changes/migrating-5-6.html#get-data-command","text":"To get data you need to obtain a Seos session, you may for instance use the one described previously. Then create and run a get data command. Note that you might have different requirements that prevents you from using the session described in Accessing the Seos Access API. The generic data object get command is described below. 1 2 3 4 5 6 7 8 9 10 11 12 13 //... Command < DataObject > readDataCommand = getSeosObject ( dataObject ( /*depending on what object you want*/ )); CommandResult < DataObject > result = session . execute ( readDataCommand ); if ( result . status () == CommandResult . Status . SUCCESS ) { // Success DataObject dataObject = result . responseData (); } else { // Failure }","title":"Get data command"},{"location":"api-changes/migrating-5-6.html#get-authentication-info","text":"Authentication info contains the oid last used to authenticate and the authentication counter. In order to get the information, you need to obtain a Seos session and then create and run the specific 'last authentication info' command. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //... Command < AuthenticationInfo > getDataCommand = Commands . getSeosObject ( SeosObjects . LAST_AUTHENTICATION_INFO ); CommandResult < AuthenticationInfo > result = session . execute ( getDataCommand ); if ( result . status () == CommandResult . Status . SUCCESS ) { // Success Oid oid = getDataResult . responseData (). lastAuthenticatedOid (); int counter = getDataResults . responseData (). authenticationCounter () } else { // Failure }","title":"Get authentication info"},{"location":"api-changes/migrating-6_6-6_7.html","text":"Migrating to 6.7.x In order to improve security and performance, Google has decided to enforce targetSdkVersion >= 26 for new apps and updates to existing apps. In short: In August 2018, Google will no longer accept new applications with targetSdkVersion < 26. In September 2018, Google will no longer accept updates to existing applications with targetSdkVersion < 26. What are the implications? In SDK 26, new restrictions are present regarding how one may use background services. Any app running in the background will no longer be able to start background services. As the Seos Mobile SDK provides functionality for scanning for Bluetooth readers in the background, a few things have changed in the 6.7.0 release of the Seos Mobile SDK for Android What needs to be done by the integrators? Background scanning ( ReaderConnectionController#startScanning ) is now disabled by default so that consumers of the SDK don't unknowingly overlook the necessary changes needed for applications to work properly. To enable background scanning again, one would need to set allowBackgroundScanning to true in ScanConfiguration (either directly through the constructor or through the builder). If background scanning is enabled, adjustments to the application will be necessary: ReaderConnectionController#startScanning must not be called while your application is in the background on devices running Android API level >= 26. If it is, the application will crash. If startScanning is called while your application is in the foreground, it will keep scanning while the application remains in the foreground, but will be stopped by the Android operating system after some time if the application is put in the background. If scanning while the application is running in the background is desired on devices running Android API level >= 26 you must use ReaderConnectionController#startForegroundScanning Other changes: ReaderConnectionController#startForegroundScanning does not allow the notification argument to be null anymore. Either pass a notification, or use ReaderConnectionController#startScanning while taking the precautions described above.","title":"6.6.x to 6.7.0"},{"location":"api-changes/migrating-6_6-6_7.html#migrating-to-67x","text":"In order to improve security and performance, Google has decided to enforce targetSdkVersion >= 26 for new apps and updates to existing apps. In short: In August 2018, Google will no longer accept new applications with targetSdkVersion < 26. In September 2018, Google will no longer accept updates to existing applications with targetSdkVersion < 26.","title":"Migrating to 6.7.x"},{"location":"api-changes/migrating-6_6-6_7.html#what-are-the-implications","text":"In SDK 26, new restrictions are present regarding how one may use background services. Any app running in the background will no longer be able to start background services. As the Seos Mobile SDK provides functionality for scanning for Bluetooth readers in the background, a few things have changed in the 6.7.0 release of the Seos Mobile SDK for Android","title":"What are the implications?"},{"location":"api-changes/migrating-6_6-6_7.html#what-needs-to-be-done-by-the-integrators","text":"Background scanning ( ReaderConnectionController#startScanning ) is now disabled by default so that consumers of the SDK don't unknowingly overlook the necessary changes needed for applications to work properly. To enable background scanning again, one would need to set allowBackgroundScanning to true in ScanConfiguration (either directly through the constructor or through the builder). If background scanning is enabled, adjustments to the application will be necessary: ReaderConnectionController#startScanning must not be called while your application is in the background on devices running Android API level >= 26. If it is, the application will crash. If startScanning is called while your application is in the foreground, it will keep scanning while the application remains in the foreground, but will be stopped by the Android operating system after some time if the application is put in the background. If scanning while the application is running in the background is desired on devices running Android API level >= 26 you must use ReaderConnectionController#startForegroundScanning","title":"What needs to be done by the integrators?"},{"location":"api-changes/migrating-6_6-6_7.html#other-changes","text":"ReaderConnectionController#startForegroundScanning does not allow the notification argument to be null anymore. Either pass a notification, or use ReaderConnectionController#startScanning while taking the precautions described above.","title":"Other changes:"},{"location":"api-changes/migrating-6_7-7_0.html","text":"Migrating to 7.0.0 When upgrading from 6.7.0 or later, only minimal changes are required. If the Mobile Keys SDK haven't been updated to 6.7.0, refer to its migration guide. Note that @Experimental API:s can change between versions without causing a MAJOR version release. This includes the new Bluetooth modes. BREAKING CHANGES: Java bytecode version has been updated to 1.8. This needs to be updated in the integrating applications as well. Three new dependencies are now needed (with the following versions at the time of release): - org.jetbrains.kotlin:kotlin-stdlib:1.3.11 - org.jetbrains.kotlinx:kotlinx-coroutines-core:1.0.1 - org.jetbrains.kotlinx:kotlinx-coroutines-android:1.0.1 Renamed classes: HceConnectionInfoType -> ReaderConnectionInfoType HceConnectionEventType -> ReaderConnectionEventType Removed methods: Reader::lastScan() Use Reader::lastScanTimeStamp instead. If you need the time stamp in Unix time, use the following: System.currentTimeMillis() - SystemClock.elapsedRealtime() + reader.lastScanTimeStamp() EndpointInfo::getEndpointId Use EndpointInfo::getSeosId instead Reader::protocolVersion Use Reader::profileVersion instead Reader::normalizedFilteredRssi Use Reader::rssi instead Exceptions: openSeosAccessApiSession now doesn't throw SessionException","title":"6.7+ to 7.0"},{"location":"api-changes/migrating-6_7-7_0.html#migrating-to-700","text":"When upgrading from 6.7.0 or later, only minimal changes are required. If the Mobile Keys SDK haven't been updated to 6.7.0, refer to its migration guide. Note that @Experimental API:s can change between versions without causing a MAJOR version release. This includes the new Bluetooth modes.","title":"Migrating to 7.0.0"},{"location":"api-changes/migrating-6_7-7_0.html#breaking-changes","text":"Java bytecode version has been updated to 1.8. This needs to be updated in the integrating applications as well. Three new dependencies are now needed (with the following versions at the time of release): - org.jetbrains.kotlin:kotlin-stdlib:1.3.11 - org.jetbrains.kotlinx:kotlinx-coroutines-core:1.0.1 - org.jetbrains.kotlinx:kotlinx-coroutines-android:1.0.1","title":"BREAKING CHANGES:"},{"location":"api-changes/migrating-6_7-7_0.html#renamed-classes","text":"HceConnectionInfoType -> ReaderConnectionInfoType HceConnectionEventType -> ReaderConnectionEventType","title":"Renamed classes:"},{"location":"api-changes/migrating-6_7-7_0.html#removed-methods","text":"Reader::lastScan() Use Reader::lastScanTimeStamp instead. If you need the time stamp in Unix time, use the following: System.currentTimeMillis() - SystemClock.elapsedRealtime() + reader.lastScanTimeStamp() EndpointInfo::getEndpointId Use EndpointInfo::getSeosId instead Reader::protocolVersion Use Reader::profileVersion instead Reader::normalizedFilteredRssi Use Reader::rssi instead","title":"Removed methods:"},{"location":"api-changes/migrating-6_7-7_0.html#exceptions","text":"openSeosAccessApiSession now doesn't throw SessionException","title":"Exceptions:"},{"location":"errors/gatt-errors.html","text":"Background These are the errors that are returned by the Bluetooth API's in Android (Bluedroid / gatt_api.h). Most of them are taken from the java source code comments, and a few are also from native header file comments. Connection statuses Error Name Description 0 GATT_CONN_UNKNOWN Unknown / no error 0x01 GATT_CONN_NO_RESOURCES Connection fail for l2cap resource failure 0x08 GATT_CONN_TIMEOUT Connection timeout 0x13 GATT_CONN_TERMINATE_PEER_USER Connection terminate by peer user 0x16 GATT_CONN_TERMINATE_LOCAL_HOST Connection terminated by local host 0x03E GATT_CONN_FAIL_ESTABLISH Connection fail to establish 0x22 GATT_CONN_LMP_TIMEOUT Connection fail for LMP response timeout 0x010 GATT_CONN_CANCEL L2CAP connection cancelled Operation statuses Error Name Description 0x0000 GATT_SUCCESS operation completed successfully 0x0001 GATT_INVALID_HANDLE Invalid handle 0x0002 GATT_READ_NOT_PERMIT GATT read operation not permitted 0x0003 GATT_WRITE_NOT_PERMIT Gatt write operation not permitted 0x0004 GATT_INVALID_PDU Invalid protocol data unit 0x0005 GATT_INSUF_AUTHENTICATION Insuficcient authentication for the given operation 0x0006 GATT_REQ_NOT_SUPPORTED The given request is not supported 0x0007 GATT_INVALID_OFFSET The read or write operation was requested with an invalid offset 0x0008 GATT_INSUF_AUTHORIZATION Insufficient authorization 0x0009 GATT_PREPARE_Q_FULL Prepare queue full 0x000a GATT_NOT_FOUND Not long 0x000b GATT_NOT_LONG Not found 0x000c GATT_INSUF_KEY_SIZE Insufficient key size 0x000d GATT_INVALID_ATTR_LEN The write operation exceeds the maximum length of the attribute 0x000e GATT_ERR_UNLIKELY Error unlikely 0x000f GATT_INSUF_ENCRYPTION Insufficient encryption for a given operation 0x0010 GATT_UNSUPPORT_GRP_TYPE Unsupported group type 0x0011 GATT_INSUF_RESOURCE Insufficient resource 0x0087 GATT_ILLEGAL_PARAMETER Illegal parameter 0x0080 GATT_NO_RESOURCES No resources 0x0081 GATT_INTERNAL_ERROR Internal error 0x0082 GATT_WRONG_STATE Wrong state 0x0083 GATT_DB_FULL Database full 0x0084 GATT_BUSY Busy 0x0085 GATT_ERROR General GATT error 0x0086 GATT_CMD_STARTED Command started 0x0088 GATT_PENDING Pending 0x0089 GATT_AUTH_FAIL Authentication failure 0x008a GATT_MORE More 0x008b GATT_INVALID_CFG Invalid configuration 0x008c GATT_SERVICE_STARTED Service started 0x0000 GATT_ENCRYPED_MITM Encrypted man in the middle 0x008d GATT_ENCRYPED_NO_MITM Encrypted no man in the middle 0x008e GATT_NOT_ENCRYPTED Not encrypted","title":"GATT errors"},{"location":"errors/gatt-errors.html#background","text":"These are the errors that are returned by the Bluetooth API's in Android (Bluedroid / gatt_api.h). Most of them are taken from the java source code comments, and a few are also from native header file comments.","title":"Background"},{"location":"errors/gatt-errors.html#connection-statuses","text":"Error Name Description 0 GATT_CONN_UNKNOWN Unknown / no error 0x01 GATT_CONN_NO_RESOURCES Connection fail for l2cap resource failure 0x08 GATT_CONN_TIMEOUT Connection timeout 0x13 GATT_CONN_TERMINATE_PEER_USER Connection terminate by peer user 0x16 GATT_CONN_TERMINATE_LOCAL_HOST Connection terminated by local host 0x03E GATT_CONN_FAIL_ESTABLISH Connection fail to establish 0x22 GATT_CONN_LMP_TIMEOUT Connection fail for LMP response timeout 0x010 GATT_CONN_CANCEL L2CAP connection cancelled","title":"Connection statuses"},{"location":"errors/gatt-errors.html#operation-statuses","text":"Error Name Description 0x0000 GATT_SUCCESS operation completed successfully 0x0001 GATT_INVALID_HANDLE Invalid handle 0x0002 GATT_READ_NOT_PERMIT GATT read operation not permitted 0x0003 GATT_WRITE_NOT_PERMIT Gatt write operation not permitted 0x0004 GATT_INVALID_PDU Invalid protocol data unit 0x0005 GATT_INSUF_AUTHENTICATION Insuficcient authentication for the given operation 0x0006 GATT_REQ_NOT_SUPPORTED The given request is not supported 0x0007 GATT_INVALID_OFFSET The read or write operation was requested with an invalid offset 0x0008 GATT_INSUF_AUTHORIZATION Insufficient authorization 0x0009 GATT_PREPARE_Q_FULL Prepare queue full 0x000a GATT_NOT_FOUND Not long 0x000b GATT_NOT_LONG Not found 0x000c GATT_INSUF_KEY_SIZE Insufficient key size 0x000d GATT_INVALID_ATTR_LEN The write operation exceeds the maximum length of the attribute 0x000e GATT_ERR_UNLIKELY Error unlikely 0x000f GATT_INSUF_ENCRYPTION Insufficient encryption for a given operation 0x0010 GATT_UNSUPPORT_GRP_TYPE Unsupported group type 0x0011 GATT_INSUF_RESOURCE Insufficient resource 0x0087 GATT_ILLEGAL_PARAMETER Illegal parameter 0x0080 GATT_NO_RESOURCES No resources 0x0081 GATT_INTERNAL_ERROR Internal error 0x0082 GATT_WRONG_STATE Wrong state 0x0083 GATT_DB_FULL Database full 0x0084 GATT_BUSY Busy 0x0085 GATT_ERROR General GATT error 0x0086 GATT_CMD_STARTED Command started 0x0088 GATT_PENDING Pending 0x0089 GATT_AUTH_FAIL Authentication failure 0x008a GATT_MORE More 0x008b GATT_INVALID_CFG Invalid configuration 0x008c GATT_SERVICE_STARTED Service started 0x0000 GATT_ENCRYPED_MITM Encrypted man in the middle 0x008d GATT_ENCRYPED_NO_MITM Encrypted no man in the middle 0x008e GATT_NOT_ENCRYPTED Not encrypted","title":"Operation statuses"},{"location":"errors/sdk-errors.html","text":"Background These are the error codes that is returned by the SDK Public error code Code Description Recommended action INTERNAL_ERROR An internal error occurred Retry or contact the key administrator if problem persists. INVALID_INVITATION_CODE The TSM reported that the invitation code was invalid. Retype or contact the key administrator. DEVICE_SETUP_FAILED The TSM failed to install the endpoint with a fatal error (FATAL, the invitation code is consumed and can not be reused). Contact the key administrator and request a new invitation code. SERVER_UNREACHABLE The server communication failed. This is normally because of a network problem. Check internet connectivity or try again later. SDK_INCOMPATIBLE Server replied API INCOMPATIBLE. The TSM reported that the current version of the SDK is too old. upgrade the application. SDK_BUSY One asynchronous method of the API is already running. Retry previous action. DEVICE_NOT_ELIGIBLE The TSM replied NOT ELIGIBLE (FATAL during Setup, the invitation code is consumed and can not be reused). Contact the key administrator. ENDPOINT_NOT_SETUP Attempt to invoke a method which requires an endpoint that is setup. Contact the key administrator and request an invitation code. VAULT_CORRUPT The local Seos vault was corrupted and has been reset. Retry or contact the key administrator if problem persists.","title":"SDK errors"},{"location":"errors/sdk-errors.html#background","text":"These are the error codes that is returned by the SDK","title":"Background"},{"location":"errors/sdk-errors.html#public-error-code","text":"Code Description Recommended action INTERNAL_ERROR An internal error occurred Retry or contact the key administrator if problem persists. INVALID_INVITATION_CODE The TSM reported that the invitation code was invalid. Retype or contact the key administrator. DEVICE_SETUP_FAILED The TSM failed to install the endpoint with a fatal error (FATAL, the invitation code is consumed and can not be reused). Contact the key administrator and request a new invitation code. SERVER_UNREACHABLE The server communication failed. This is normally because of a network problem. Check internet connectivity or try again later. SDK_INCOMPATIBLE Server replied API INCOMPATIBLE. The TSM reported that the current version of the SDK is too old. upgrade the application. SDK_BUSY One asynchronous method of the API is already running. Retry previous action. DEVICE_NOT_ELIGIBLE The TSM replied NOT ELIGIBLE (FATAL during Setup, the invitation code is consumed and can not be reused). Contact the key administrator. ENDPOINT_NOT_SETUP Attempt to invoke a method which requires an endpoint that is setup. Contact the key administrator and request an invitation code. VAULT_CORRUPT The local Seos vault was corrupted and has been reset. Retry or contact the key administrator if problem persists.","title":"Public error code"},{"location":"errors/status-words.html","text":"Background Seos uses status words defined in ISO 7816 documents, mainly ISO 7816-3 and ISO 7816-4. While the integrating application generally don't have to care about these errors, they are kept here for reference Error Meaning 9000 No error 6999 Applet selection failed 61xx Response bytes remaining 6E00 CLA value not supported 6986 Command not allowed (no current EF) 6985 Conditions of use not satisfied 6C00 Correct Expected Length (Le) 6984 Data invalid 6988 Secure messaging data objects incorrect 6A84 Not enough memory space in the file 6983 File invalid 6A82 File not found 6A81 Function not supported 6A86 Incorrect parameters (P1,P2) 6D00 INS value not supported 6A83 Record not found 6982 Security condition not satisfied 6F00 No precise diagnosis 6A80 Wrong data 6700 Wrong length 6B00 Wrong parameters (P1,P2)","title":"Seos status words"},{"location":"errors/status-words.html#background","text":"Seos uses status words defined in ISO 7816 documents, mainly ISO 7816-3 and ISO 7816-4. While the integrating application generally don't have to care about these errors, they are kept here for reference Error Meaning 9000 No error 6999 Applet selection failed 61xx Response bytes remaining 6E00 CLA value not supported 6986 Command not allowed (no current EF) 6985 Conditions of use not satisfied 6C00 Correct Expected Length (Le) 6984 Data invalid 6988 Secure messaging data objects incorrect 6A84 Not enough memory space in the file 6983 File invalid 6A82 File not found 6A81 Function not supported 6A86 Incorrect parameters (P1,P2) 6D00 INS value not supported 6A83 Record not found 6982 Security condition not satisfied 6F00 No precise diagnosis 6A80 Wrong data 6700 Wrong length 6B00 Wrong parameters (P1,P2)","title":"Background"},{"location":"getting-started/custom-tsm.html","text":"Custom TSM environment It is possible to use environments not hosted by ASSA ABLOY mobile services: 1 2 3 4 5 6 7 8 9 10 11 import com.assaabloy.mobilekeys.api.ApiConfiguration ; import com.assaabloy.mobilekeys.api.tsm.Environment ; Environment customEnv = new Environment ( tsmUrl , \"My Custom TSM\" , publicKey ); // pass ApiConfiguration to MobileKeysApi::initialize ApiConfiguration apiConf = new ApiConfiguration . Builder () . setApplicationId ( applicationId ) . setApplicationDescription ( description ) . setEnvironment ( customEnv ) . build (); Here is how you can extract a publickey sha256 fingerprint from a PEM certificate using openssl: 1 2 3 4 openssl x509 - in certificate . pem - pubkey - noout \\ | openssl pkey - pubin - outform der \\ | openssl dgst - sha256 - binary \\ | openssl enc - base64 To use a custom AKE key for personalization: 1 2 3 4 5 6 7 8 EndpointSetupConfiguration configuration = new EndpointSetupConfiguration . Builder () . setApplicationProperties ( applicationProperties ) . setSetupAkeKey ( new SetupAkeKeyUnprotected ( bytes )) . build (); mobileKeys . endpointSetup ( callback , activationCode , configuration );","title":"Custom TSM"},{"location":"getting-started/custom-tsm.html#custom-tsm-environment","text":"It is possible to use environments not hosted by ASSA ABLOY mobile services: 1 2 3 4 5 6 7 8 9 10 11 import com.assaabloy.mobilekeys.api.ApiConfiguration ; import com.assaabloy.mobilekeys.api.tsm.Environment ; Environment customEnv = new Environment ( tsmUrl , \"My Custom TSM\" , publicKey ); // pass ApiConfiguration to MobileKeysApi::initialize ApiConfiguration apiConf = new ApiConfiguration . Builder () . setApplicationId ( applicationId ) . setApplicationDescription ( description ) . setEnvironment ( customEnv ) . build (); Here is how you can extract a publickey sha256 fingerprint from a PEM certificate using openssl: 1 2 3 4 openssl x509 - in certificate . pem - pubkey - noout \\ | openssl pkey - pubin - outform der \\ | openssl dgst - sha256 - binary \\ | openssl enc - base64 To use a custom AKE key for personalization: 1 2 3 4 5 6 7 8 EndpointSetupConfiguration configuration = new EndpointSetupConfiguration . Builder () . setApplicationProperties ( applicationProperties ) . setSetupAkeKey ( new SetupAkeKeyUnprotected ( bytes )) . build (); mobileKeys . endpointSetup ( callback , activationCode , configuration );","title":"Custom TSM environment"},{"location":"getting-started/getting-started.html","text":"Android library The SDK is provided as a single Android library (.aar) file. The SDK file comes in two variants. The one with the -debug suffix is intended to be used during development. The production version of the .aar, with the -release suffix, contains anti-tampering guards, one of them crashes the application if a debugger is connected. To be able to debug applications during development a -debug version is therefore provided. Make sure to switch implementation before publishing your application! In your apps build.gradle file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 repositories { flatDir { dirs 'libs' } //... } //... dependencies { //aar file from libs dir. Name and version is from the filename. debugImplementation name: 'mobilekeys-android-sdk-debug' , version: 'x.x.x' , ext: 'aar' releaseImplementation name: 'mobilekeys-android-sdk-release' , version: 'x.x.x' , ext: 'aar' // Seos Mobile SDK transistive dependencies implementation 'org.bouncycastle:bcprov-jdk15on:1.58' implementation 'com.google.code.gson:gson:2.2.2' implementation 'org.slf4j:slf4j-api:1.7.7' implementation 'com.squareup.okhttp3:okhttp:3.9.1' implementation \"com.mixpanel.android:mixpanel-android:4.8.7@aar\" //Enable logging from Seos Mobile SDK implementation 'org.slf4j:slf4j-android:1.7.7' //... } Back Up User Data/Auto Backup The Seos Mobile Android SDK is storing encrypted, non-transferable data on the device. Using the Auto Backup functionality provided by default in Android 6.0 (API level 23) and later is therefore not supported. The easiest way to disable it is by putting the following in your AndroidManifest.xml 1 2 3 4 5 6 <manifest ... > ... <application android:allowBackup= \"false\" ... > ... </application> </manifest> If your application targets Android 6.0 (API level 23) android:allowBackup will default to true , so you will need to set the above explicitly. Enabling Auto Backup If you need to enable Auto Backup for your application you need to make certain adjustments to your app configuration. As of Seos Mobile SDK 6.5.1 this is done automatically by the SDK, but if you are using an earlier version, or if you need to exclude other files from being backed up, you need to manually specify all of them. This is done by following the instructions on https://developer.android.com/guide/topics/data/autobackup.html#IncludingFiles Your fullBackupContent resource must exclude the following files: 1 2 3 4 5 6 7 <?xml version=\"1.0\" encoding=\"utf-8\"?> <full-backup-content> <exclude domain= \"sharedpref\" path= \"soft-se.xml\" /> <exclude domain= \"sharedpref\" path= \"mobileKeysProperties.xml\" /> <!--<exclude domain=\"sharedpref\" path=\"YOUR_OWN_FILE.xml\"/>--> </full-backup-content> This will exclude the non-transferable data created by the SDK from the backup, while still backing up other data created by the app. A note on different phone models The measured RSSI Values could differ between different phone model, BLE chipsets, phone antennas, and phone firmwares. On certain phones, NFC is configured to use the SIM card only. One example is certain Samsung phones after upgrading them to Android 5.x. On these phones, the NFC processing method needs to be changed to \"Android\" instead of SIM for HCE to work. Mobile keys API The main class in the SDK is the com.assaabloy.mobilekeys.api.MobileKeysApi . It provides a centralized entry point for the seos mobile integration. The MobileKeysApi contains three parts: com.assaabloy.mobilekeys.api.MobileKeys facade is responsible for both Seos TSM communication and Seos secure element functionality. com.assaabloy.mobilekeys.api.ReaderConnectionController is used for controlling the Bluetooth and NFC reader communication. com.assaabloy.mobilekeys.api.DeviceEligibility contains device specific configurations and information about working/non working features. Initializing the API The MobileKeysApi interface is obtained via the .getInstance() method but in order to access MobileKeys and ReaderConnectionController interface the API needs to be initialized. The API is initialized via the .initialize(Context context, ApiConfiguration apiConfig, ScanConfiguration scanConfig) method. Make sure that the API isn't already initialized by calling .isInitialized() . Seos TSM integration There are five methods in the API to handle Seos TSM integration located in the com.assaabloy.mobilekeys.api.MobileKeys interface. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public interface MobileKeys { void applicationStartup ( MobileKeysCallback mobileKeysCallback , ApplicationProperty ... applicationProperties ); void endpointSetup ( MobileKeysCallback mobileKeysCallback , String activationCode , ApplicationProperty ... applicationProperties ); void endpointUpdate ( MobileKeysCallback mobileKeysCallback ); boolean isEndpointSetupComplete () throws MobileKeysException ; void unregisterEndpoint ( MobileKeysCallback mobileKeysCallback ); //... } applicationStartup(...) , endpointUpdate(...) , endpointSetup(...) are time consuming operations. They will be executed asynchronously on a background thread and the result will be delivered to the calling application via the com.assaabloy.mobilekeys.api.MobileKeysCallback instance given as the first parameter. There is a subclass of the callback interface, com.assaabloy.mobilekeys.api.MobileKeysProgressCallback , which has an additional method sending progress events during a setup or update. There is no way of telling how many events will come before the setup/update is finished, so this information can't be used for filling a progress bar, but it could be used for giving the user some other form of feedback. The call that takes the most time is the endpoint setup. This process could take between a few seconds up to about a minute. For that reason it's important to give the user feedback during the process and set the user's expectations before the process is started, otherwise the user might think the application is not responding. Application startup The application startup method should, as the name implies, be called during the startup phase of your application. This method will make sure that the phone is in sync with the Seos TSM server. It will: Send properties about the installation to the Seos TSM, e.g. version of the Mobile SDK or Android OS. The SDK will detect when a property has changed and only perform update if necessary. Detect interrupted communication with the Seos TSM and try to resume. Normally server communication should not be interrupted but in case of an application crash or memory issues on the phone, shutting down the application, the SDK persists outgoing messages to the Seos TSM. In case there is a message pending during application startup it will be sent to the Seos TSM. This process might take a bit of time, since the message might trigger a response from the server requiring more actions on the phone side and so on. This is generally a fast operation, since it will require no communication with the Seos TSM, but might sometimes take a bit more time if Seos TSM interaction is needed. The calling application needs to handle the fact that this call might take some time before it's finished. Endpoint setup An endpoint, a Seos instance in a secure element, has to be installed and personalized before it can be used to open locks. The first thing a application has to do is to check if the endpoint setup on this device is completed (using the com.assaabloy.mobilekeys.api.MobileKeys.isEndpointSetupComplete() method). If not, the application needs to call com.assaabloy.mobilekeys.api.MobileKeys.endpointSetup(MobileKeysCallback, String, ApplicationProperty...) and wait for the process to finish. As part of the user sign-up process the end user will be given an activation code. This code will be used to identify the endpoint in the Seos TSM, and will also be used to secure the setup process. The code is four times four alphanumerical characters separated by a dash, i.e. XXXX-XXXX-XXXX-XXXX . This code (given as a string in the format described above) is a required parameter to the endpoint setup method. If the user is already authenticated eg. using a backend server outside the TSM environment there is no need to send the code to the user. Instead, the application can retrieve the invitation code from the backend server and feed it directly to the setup method in the SDK. Thus the user would be transparently enrolled. Note that the endpoint setup includes multiple roundtrips between the SDK and the Seos TSM. This might fail on a mobile data network. The application can re-try calling endpoint setup at a later time, when the phone has a stable network connection, with the same activation code. The only exception is if the SDK report an error with error code com.assaabloy.mobilekeys.api.MobileKeysApiErrorCode.DEVICE_SETUP_FAILED . This means that the setup failed in a critical phase of the setup and, for security reasons, the application has to start over with a new activation code. Content updates New keys, revocation of keys, etc. will be delivered to the phone from the Seos TSM. In order to download and process those updates, the application needs to call com.assaabloy.mobilekeys.api.MobileKeys.endpointUpdate(MobileKeysCallback) . The application could do this update every time it is launched, or the application backend could use some kind of push mechanism to tell the application when an update is available. Talking to Seos in the secure element The com.assaabloy.mobilekeys.api.MobileKeys interface contains functionality to talk to Seos that will cover the most common use cases. For the more advanced use cases you can use the Seos Access API. The Seos Access API provides a high level Java API for integrating with the Seos Card Technology. Please refer to it's documentation about how to use it. Due to the single threaded nature of most secure elements the MobileKeys implementation will make sure that only one task is performed at a time, i.e. one current request to list keys or one time consuming Seos TSM request. If there is already a request processing or a Seos TSM task running, a com.assaabloy.mobilekeys.api.MobileKeysException with the error code API_IS_BUSY will be thrown. Listing issued keys Retrieve a list of MobileKey objects representing all keys issued to this secure element using the listMobileKeys() method. Each mobile key holds metadata about the key, like label, valid from/to dates, etc. If an application needs more information about the key, the metadata field \"configuration URL\" could be used to fetch more information from a remote server. E.g. in our reference application we point this URL to a XML document describing key card layout, background image, font size and color etc. Reading metadata about Seos The getEndpointInfo() method provides metadata about the Seos installation. See com.assaabloy.mobilekeys.api.EndpointInfo for more details about available data. This data is typically not useful for an end user but could be helpful for a support technician. We therefore encourage integrators to make this information available in some kind of help, support or about screen. Observing changes It is possible to listen to keys and endpoint changes in the SDK by adding listeners to the com.assaabloy.mobilekeys.api.MobileKeys interface. Bluetooth reader integration The phone communicates to Bluetooth readers using Bluetooth Low Energy (also known as Bluetooth LE, BLE or Bluetooth Smart). Bluetooth LE was released as part of the Bluetooth 4.0 Core Specification, and Android support was first released as part of Android 4.3. The Android 5.0 release significantly improved the Bluetooth LE support in Android, with e.g. less power consumption and support for scanning with screen off. With the increased user integrity and privacy of Android 6.0 Bluetooth LE scanning now requires location permissions. The Bluetooth implementation is hidden behind the com.assaabloy.mobilekeys.api.ReaderConnectionController interface. As an integrator you need to verify that the application supports Bluetooth before scanning. For this purpose you can use the BluetoothSupportHelper class in the in the SDK that helps you check if a device has the features required to be used with Bluetooth readers. The Bluetooth service will handle discovering readers and start an opening sequence when appropriate. To start scanning the service needs the configuration parameters described below. Due to battery consumption issues in Android 4.3 and 4.4, on these devices scanning is only performed when the phone screen is on. The service will automatically detect screen on/off events and stop/start scanning accordingly. On Android 5.0+ devices scanning will continue even when the phone screen is off. The user might experience a performance drop for proximity and seamless modes, as the Android OS automatically slows down scanning to save power when the screen is off. BLE configuration When starting scanning in the BLE service you need to provide a ScanConfiguration instance. The scan configuration contains the following parameters. Parameter Description Lock service code(s) Bluetooth readers advertise a UUID (universally unique identifier) identifying this BLE device as a reader. The lock service code is part of that UUID. The UUID might differ between different types of readers. Consult with your lock provider to receive the service code used by the reader you want to integrate to. RSSI sensitivity RSSI values are used to calculate distance to a reader. These values differ between different phone manufacturers, models and even individual phones. On a device where e.g. the proximity mode works poorly and the user would have to almost touch the reader with his phone, the signal can be boosted by specifying RssiSensitivity.HIGH, and if the device opens a lock at too long range, you would use RssiSensitivity.LOW. To use the RSSI values received from the lock, without modifications, specify RssiSensitivity.NORMAL. This could be presented as a setting for the user, or tuned as part of some kind of automatic process. Scan mode (optional) Mode to indicate to the SDK if the application wants to prioritize power consumption or performance when scanning for BLE readers. The scan mode setting only works in Android 5.0, and will be ignored on 4.3 and 4.4 devices. The default setting is to prioritize the power consumption. BLE opening triggers List of opening trigger implementations that the application wants to enable. The SDK provides three implementations: Twist and Go, Proximity and Seamless. Use the utility method ScanConfiguration.providedOpeningMethods(...) if you are only interested in using implementations provided by the SDK. To change configuration parameters once the scanning is started all you need to do is update the ScanConfiguration instance with new configuration parameters. Opening modes There are several types of opening modes supported by a Bluetooth reader. A reader can be configured to support one or more of these opening modes. Support for more opening modes are planned for future releases of the SDK. The modes currently supported are: Proximity . The phone behaves like an access card or tag, e.g. you have to hold the phone within close proximity to the reader. Seamless . Opens the lock as the user approaches. This obviously works best with Android 5.0 as the user is not required to power on the screen, but could be used with older models as well with the restriction that the user has to power on his screen. Seamless is not suitable for all readers and environments, consult with your reader provider for more details. Twist and Go . The user turns the phone 90 degrees in one direction and then back again. This will open the closest reader within range. To implement custom opening mode look at the documentation on ( com.assaabloy.mobilekeys.api.ble.OpeningTrigger ). The ReaderConnectionController also supports manual opening but the underlying mechanism still relies on opening triggers. Reader connection callbacks Callbacks are delivered to the implementing application via the com.assaabloy.mobilekeys.api.ble.ReaderConnectionCallback interface. The Bluetooth LE service will notify the connection listener when a reader connection is opened, closed or has failed. These methods are typically used to give the user feedback, using sound, vibration or UI. Please not that in some failure cases the Reader parameter in the callback might be null, e.g. when the user performed an open motion with no readers within range. See the javadoc for the com.assaabloy.mobilekeys.api.ble.ReaderConnectionCallback and related classes for more details on how to register for and handle callbacks. Limitations A Bluetooth LE reader can only make one connection at a time. So when two apps simultaneously try to open using bluetooth; opening will be very slow. Host-based Card Emulation (NFC) Android 4.4 introduced a way for an Android device to emulate a contactless card using NFC. This feature is referred to as Host-based Card Emulation (HCE). Full documentation of this feature can be found in the Android API guides. The SDK contains a service implementing HCE. The service is disabled by default but can be enabled and disabled using the com.assaabloy.mobilekeys.api.ReaderConnectionController . To configure the HCE service you need to be assigned an AID by ASSA ABLOY. When you have received an AID you have to create an seos_hce_service.xml file, add your HCE AID, and provide it as a resource. HCE configuration file res/xml/seos_hce_service.xml : 1 2 3 4 5 6 7 8 9 <?xml version=\"1.0\" encoding=\"utf-8\"?> <host-apdu-service xmlns:android= \"http://schemas.android.com/apk/res/android\" android:description= \"@string/seos_hce_description\" android:requireDeviceUnlock= \"false\" > <aid-group android:description= \"@string/seos_hce_aid_description\" android:category= \"other\" > <!-- Specify your AID here, will be assigned to you by ASSA ABLOY! --> <aid-filter android:name= \"...\" /> </aid-group> </host-apdu-service> Reader connection callbacks Callbacks are delivered to the implementing application via the com.assaabloy.mobilekeys.api.hce.HceConnectionCallback interface. The HCE service will notify the connection listener when a reader connection is opened, closed or has failed. These methods are typically used to give the user feedback, using sound, vibration or UI. See the javadoc for the com.assaabloy.mobilekeys.api.hce.HceConnectionCallback and related classes for more details on how to register for and handle callbacks. Limitations The OS selects the HCE service is based on AID. If the device have several applications implementing the same AID, the user will either be prompted to select the application to use or the system will choose the default application. To avoid the prompt: make sure to register com.assaabloy.mobilekeys.api.hce.HceService` as preferred service. To make the HceService work in background you have to make sure that the MobileKeysApi is initialized. This can be achieved by extending the the Android application and initialize the MobileKeysApi in the onCreate() callback. Device eligibility Version 5.2 of the SDK introduced a way to check eligibility of the device the SDK is running on. The com.assaabloy.mobilekeys.api.DeviceEligibility contains information about working/non working features for the device. It also contains recommended RSSI settings for the device. This feature should be used before initializing the API and could be used to customize the user experience, e.g. turning off NFC on devices where NFC is known to fail. Device Status The class com.assaabloy.mobilekeys.api.util.DeviceStatus contains information about the Device's current status in regards to BLE and NFC. It can be asked about permissions, system supported features, and other things.","title":"Getting started with the SDK"},{"location":"getting-started/getting-started.html#android-library","text":"The SDK is provided as a single Android library (.aar) file. The SDK file comes in two variants. The one with the -debug suffix is intended to be used during development. The production version of the .aar, with the -release suffix, contains anti-tampering guards, one of them crashes the application if a debugger is connected. To be able to debug applications during development a -debug version is therefore provided. Make sure to switch implementation before publishing your application! In your apps build.gradle file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 repositories { flatDir { dirs 'libs' } //... } //... dependencies { //aar file from libs dir. Name and version is from the filename. debugImplementation name: 'mobilekeys-android-sdk-debug' , version: 'x.x.x' , ext: 'aar' releaseImplementation name: 'mobilekeys-android-sdk-release' , version: 'x.x.x' , ext: 'aar' // Seos Mobile SDK transistive dependencies implementation 'org.bouncycastle:bcprov-jdk15on:1.58' implementation 'com.google.code.gson:gson:2.2.2' implementation 'org.slf4j:slf4j-api:1.7.7' implementation 'com.squareup.okhttp3:okhttp:3.9.1' implementation \"com.mixpanel.android:mixpanel-android:4.8.7@aar\" //Enable logging from Seos Mobile SDK implementation 'org.slf4j:slf4j-android:1.7.7' //... }","title":"Android library"},{"location":"getting-started/getting-started.html#back-up-user-dataauto-backup","text":"The Seos Mobile Android SDK is storing encrypted, non-transferable data on the device. Using the Auto Backup functionality provided by default in Android 6.0 (API level 23) and later is therefore not supported. The easiest way to disable it is by putting the following in your AndroidManifest.xml 1 2 3 4 5 6 <manifest ... > ... <application android:allowBackup= \"false\" ... > ... </application> </manifest> If your application targets Android 6.0 (API level 23) android:allowBackup will default to true , so you will need to set the above explicitly.","title":"Back Up User Data/Auto Backup"},{"location":"getting-started/getting-started.html#enabling-auto-backup","text":"If you need to enable Auto Backup for your application you need to make certain adjustments to your app configuration. As of Seos Mobile SDK 6.5.1 this is done automatically by the SDK, but if you are using an earlier version, or if you need to exclude other files from being backed up, you need to manually specify all of them. This is done by following the instructions on https://developer.android.com/guide/topics/data/autobackup.html#IncludingFiles Your fullBackupContent resource must exclude the following files: 1 2 3 4 5 6 7 <?xml version=\"1.0\" encoding=\"utf-8\"?> <full-backup-content> <exclude domain= \"sharedpref\" path= \"soft-se.xml\" /> <exclude domain= \"sharedpref\" path= \"mobileKeysProperties.xml\" /> <!--<exclude domain=\"sharedpref\" path=\"YOUR_OWN_FILE.xml\"/>--> </full-backup-content> This will exclude the non-transferable data created by the SDK from the backup, while still backing up other data created by the app.","title":"Enabling Auto Backup"},{"location":"getting-started/getting-started.html#a-note-on-different-phone-models","text":"The measured RSSI Values could differ between different phone model, BLE chipsets, phone antennas, and phone firmwares. On certain phones, NFC is configured to use the SIM card only. One example is certain Samsung phones after upgrading them to Android 5.x. On these phones, the NFC processing method needs to be changed to \"Android\" instead of SIM for HCE to work.","title":"A note on different phone models"},{"location":"getting-started/getting-started.html#mobile-keys-api","text":"The main class in the SDK is the com.assaabloy.mobilekeys.api.MobileKeysApi . It provides a centralized entry point for the seos mobile integration. The MobileKeysApi contains three parts: com.assaabloy.mobilekeys.api.MobileKeys facade is responsible for both Seos TSM communication and Seos secure element functionality. com.assaabloy.mobilekeys.api.ReaderConnectionController is used for controlling the Bluetooth and NFC reader communication. com.assaabloy.mobilekeys.api.DeviceEligibility contains device specific configurations and information about working/non working features.","title":"Mobile keys API"},{"location":"getting-started/getting-started.html#initializing-the-api","text":"The MobileKeysApi interface is obtained via the .getInstance() method but in order to access MobileKeys and ReaderConnectionController interface the API needs to be initialized. The API is initialized via the .initialize(Context context, ApiConfiguration apiConfig, ScanConfiguration scanConfig) method. Make sure that the API isn't already initialized by calling .isInitialized() .","title":"Initializing the API"},{"location":"getting-started/getting-started.html#seos-tsm-integration","text":"There are five methods in the API to handle Seos TSM integration located in the com.assaabloy.mobilekeys.api.MobileKeys interface. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public interface MobileKeys { void applicationStartup ( MobileKeysCallback mobileKeysCallback , ApplicationProperty ... applicationProperties ); void endpointSetup ( MobileKeysCallback mobileKeysCallback , String activationCode , ApplicationProperty ... applicationProperties ); void endpointUpdate ( MobileKeysCallback mobileKeysCallback ); boolean isEndpointSetupComplete () throws MobileKeysException ; void unregisterEndpoint ( MobileKeysCallback mobileKeysCallback ); //... } applicationStartup(...) , endpointUpdate(...) , endpointSetup(...) are time consuming operations. They will be executed asynchronously on a background thread and the result will be delivered to the calling application via the com.assaabloy.mobilekeys.api.MobileKeysCallback instance given as the first parameter. There is a subclass of the callback interface, com.assaabloy.mobilekeys.api.MobileKeysProgressCallback , which has an additional method sending progress events during a setup or update. There is no way of telling how many events will come before the setup/update is finished, so this information can't be used for filling a progress bar, but it could be used for giving the user some other form of feedback. The call that takes the most time is the endpoint setup. This process could take between a few seconds up to about a minute. For that reason it's important to give the user feedback during the process and set the user's expectations before the process is started, otherwise the user might think the application is not responding.","title":"Seos TSM integration"},{"location":"getting-started/getting-started.html#application-startup","text":"The application startup method should, as the name implies, be called during the startup phase of your application. This method will make sure that the phone is in sync with the Seos TSM server. It will: Send properties about the installation to the Seos TSM, e.g. version of the Mobile SDK or Android OS. The SDK will detect when a property has changed and only perform update if necessary. Detect interrupted communication with the Seos TSM and try to resume. Normally server communication should not be interrupted but in case of an application crash or memory issues on the phone, shutting down the application, the SDK persists outgoing messages to the Seos TSM. In case there is a message pending during application startup it will be sent to the Seos TSM. This process might take a bit of time, since the message might trigger a response from the server requiring more actions on the phone side and so on. This is generally a fast operation, since it will require no communication with the Seos TSM, but might sometimes take a bit more time if Seos TSM interaction is needed. The calling application needs to handle the fact that this call might take some time before it's finished.","title":"Application startup"},{"location":"getting-started/getting-started.html#endpoint-setup","text":"An endpoint, a Seos instance in a secure element, has to be installed and personalized before it can be used to open locks. The first thing a application has to do is to check if the endpoint setup on this device is completed (using the com.assaabloy.mobilekeys.api.MobileKeys.isEndpointSetupComplete() method). If not, the application needs to call com.assaabloy.mobilekeys.api.MobileKeys.endpointSetup(MobileKeysCallback, String, ApplicationProperty...) and wait for the process to finish. As part of the user sign-up process the end user will be given an activation code. This code will be used to identify the endpoint in the Seos TSM, and will also be used to secure the setup process. The code is four times four alphanumerical characters separated by a dash, i.e. XXXX-XXXX-XXXX-XXXX . This code (given as a string in the format described above) is a required parameter to the endpoint setup method. If the user is already authenticated eg. using a backend server outside the TSM environment there is no need to send the code to the user. Instead, the application can retrieve the invitation code from the backend server and feed it directly to the setup method in the SDK. Thus the user would be transparently enrolled. Note that the endpoint setup includes multiple roundtrips between the SDK and the Seos TSM. This might fail on a mobile data network. The application can re-try calling endpoint setup at a later time, when the phone has a stable network connection, with the same activation code. The only exception is if the SDK report an error with error code com.assaabloy.mobilekeys.api.MobileKeysApiErrorCode.DEVICE_SETUP_FAILED . This means that the setup failed in a critical phase of the setup and, for security reasons, the application has to start over with a new activation code.","title":"Endpoint setup"},{"location":"getting-started/getting-started.html#content-updates","text":"New keys, revocation of keys, etc. will be delivered to the phone from the Seos TSM. In order to download and process those updates, the application needs to call com.assaabloy.mobilekeys.api.MobileKeys.endpointUpdate(MobileKeysCallback) . The application could do this update every time it is launched, or the application backend could use some kind of push mechanism to tell the application when an update is available.","title":"Content updates"},{"location":"getting-started/getting-started.html#talking-to-seos-in-the-secure-element","text":"The com.assaabloy.mobilekeys.api.MobileKeys interface contains functionality to talk to Seos that will cover the most common use cases. For the more advanced use cases you can use the Seos Access API. The Seos Access API provides a high level Java API for integrating with the Seos Card Technology. Please refer to it's documentation about how to use it. Due to the single threaded nature of most secure elements the MobileKeys implementation will make sure that only one task is performed at a time, i.e. one current request to list keys or one time consuming Seos TSM request. If there is already a request processing or a Seos TSM task running, a com.assaabloy.mobilekeys.api.MobileKeysException with the error code API_IS_BUSY will be thrown.","title":"Talking to Seos in the secure element"},{"location":"getting-started/getting-started.html#listing-issued-keys","text":"Retrieve a list of MobileKey objects representing all keys issued to this secure element using the listMobileKeys() method. Each mobile key holds metadata about the key, like label, valid from/to dates, etc. If an application needs more information about the key, the metadata field \"configuration URL\" could be used to fetch more information from a remote server. E.g. in our reference application we point this URL to a XML document describing key card layout, background image, font size and color etc.","title":"Listing issued keys"},{"location":"getting-started/getting-started.html#reading-metadata-about-seos","text":"The getEndpointInfo() method provides metadata about the Seos installation. See com.assaabloy.mobilekeys.api.EndpointInfo for more details about available data. This data is typically not useful for an end user but could be helpful for a support technician. We therefore encourage integrators to make this information available in some kind of help, support or about screen.","title":"Reading metadata about Seos"},{"location":"getting-started/getting-started.html#observing-changes","text":"It is possible to listen to keys and endpoint changes in the SDK by adding listeners to the com.assaabloy.mobilekeys.api.MobileKeys interface.","title":"Observing changes"},{"location":"getting-started/getting-started.html#bluetooth-reader-integration","text":"The phone communicates to Bluetooth readers using Bluetooth Low Energy (also known as Bluetooth LE, BLE or Bluetooth Smart). Bluetooth LE was released as part of the Bluetooth 4.0 Core Specification, and Android support was first released as part of Android 4.3. The Android 5.0 release significantly improved the Bluetooth LE support in Android, with e.g. less power consumption and support for scanning with screen off. With the increased user integrity and privacy of Android 6.0 Bluetooth LE scanning now requires location permissions. The Bluetooth implementation is hidden behind the com.assaabloy.mobilekeys.api.ReaderConnectionController interface. As an integrator you need to verify that the application supports Bluetooth before scanning. For this purpose you can use the BluetoothSupportHelper class in the in the SDK that helps you check if a device has the features required to be used with Bluetooth readers. The Bluetooth service will handle discovering readers and start an opening sequence when appropriate. To start scanning the service needs the configuration parameters described below. Due to battery consumption issues in Android 4.3 and 4.4, on these devices scanning is only performed when the phone screen is on. The service will automatically detect screen on/off events and stop/start scanning accordingly. On Android 5.0+ devices scanning will continue even when the phone screen is off. The user might experience a performance drop for proximity and seamless modes, as the Android OS automatically slows down scanning to save power when the screen is off.","title":"Bluetooth reader integration"},{"location":"getting-started/getting-started.html#ble-configuration","text":"When starting scanning in the BLE service you need to provide a ScanConfiguration instance. The scan configuration contains the following parameters. Parameter Description Lock service code(s) Bluetooth readers advertise a UUID (universally unique identifier) identifying this BLE device as a reader. The lock service code is part of that UUID. The UUID might differ between different types of readers. Consult with your lock provider to receive the service code used by the reader you want to integrate to. RSSI sensitivity RSSI values are used to calculate distance to a reader. These values differ between different phone manufacturers, models and even individual phones. On a device where e.g. the proximity mode works poorly and the user would have to almost touch the reader with his phone, the signal can be boosted by specifying RssiSensitivity.HIGH, and if the device opens a lock at too long range, you would use RssiSensitivity.LOW. To use the RSSI values received from the lock, without modifications, specify RssiSensitivity.NORMAL. This could be presented as a setting for the user, or tuned as part of some kind of automatic process. Scan mode (optional) Mode to indicate to the SDK if the application wants to prioritize power consumption or performance when scanning for BLE readers. The scan mode setting only works in Android 5.0, and will be ignored on 4.3 and 4.4 devices. The default setting is to prioritize the power consumption. BLE opening triggers List of opening trigger implementations that the application wants to enable. The SDK provides three implementations: Twist and Go, Proximity and Seamless. Use the utility method ScanConfiguration.providedOpeningMethods(...) if you are only interested in using implementations provided by the SDK. To change configuration parameters once the scanning is started all you need to do is update the ScanConfiguration instance with new configuration parameters.","title":"BLE configuration"},{"location":"getting-started/getting-started.html#opening-modes","text":"There are several types of opening modes supported by a Bluetooth reader. A reader can be configured to support one or more of these opening modes. Support for more opening modes are planned for future releases of the SDK. The modes currently supported are: Proximity . The phone behaves like an access card or tag, e.g. you have to hold the phone within close proximity to the reader. Seamless . Opens the lock as the user approaches. This obviously works best with Android 5.0 as the user is not required to power on the screen, but could be used with older models as well with the restriction that the user has to power on his screen. Seamless is not suitable for all readers and environments, consult with your reader provider for more details. Twist and Go . The user turns the phone 90 degrees in one direction and then back again. This will open the closest reader within range. To implement custom opening mode look at the documentation on ( com.assaabloy.mobilekeys.api.ble.OpeningTrigger ). The ReaderConnectionController also supports manual opening but the underlying mechanism still relies on opening triggers.","title":"Opening modes"},{"location":"getting-started/getting-started.html#reader-connection-callbacks","text":"Callbacks are delivered to the implementing application via the com.assaabloy.mobilekeys.api.ble.ReaderConnectionCallback interface. The Bluetooth LE service will notify the connection listener when a reader connection is opened, closed or has failed. These methods are typically used to give the user feedback, using sound, vibration or UI. Please not that in some failure cases the Reader parameter in the callback might be null, e.g. when the user performed an open motion with no readers within range. See the javadoc for the com.assaabloy.mobilekeys.api.ble.ReaderConnectionCallback and related classes for more details on how to register for and handle callbacks.","title":"Reader connection callbacks"},{"location":"getting-started/getting-started.html#limitations","text":"A Bluetooth LE reader can only make one connection at a time. So when two apps simultaneously try to open using bluetooth; opening will be very slow.","title":"Limitations"},{"location":"getting-started/getting-started.html#host-based-card-emulation-nfc","text":"Android 4.4 introduced a way for an Android device to emulate a contactless card using NFC. This feature is referred to as Host-based Card Emulation (HCE). Full documentation of this feature can be found in the Android API guides. The SDK contains a service implementing HCE. The service is disabled by default but can be enabled and disabled using the com.assaabloy.mobilekeys.api.ReaderConnectionController . To configure the HCE service you need to be assigned an AID by ASSA ABLOY. When you have received an AID you have to create an seos_hce_service.xml file, add your HCE AID, and provide it as a resource. HCE configuration file res/xml/seos_hce_service.xml : 1 2 3 4 5 6 7 8 9 <?xml version=\"1.0\" encoding=\"utf-8\"?> <host-apdu-service xmlns:android= \"http://schemas.android.com/apk/res/android\" android:description= \"@string/seos_hce_description\" android:requireDeviceUnlock= \"false\" > <aid-group android:description= \"@string/seos_hce_aid_description\" android:category= \"other\" > <!-- Specify your AID here, will be assigned to you by ASSA ABLOY! --> <aid-filter android:name= \"...\" /> </aid-group> </host-apdu-service>","title":"Host-based Card Emulation (NFC)"},{"location":"getting-started/getting-started.html#reader-connection-callbacks_1","text":"Callbacks are delivered to the implementing application via the com.assaabloy.mobilekeys.api.hce.HceConnectionCallback interface. The HCE service will notify the connection listener when a reader connection is opened, closed or has failed. These methods are typically used to give the user feedback, using sound, vibration or UI. See the javadoc for the com.assaabloy.mobilekeys.api.hce.HceConnectionCallback and related classes for more details on how to register for and handle callbacks.","title":"Reader connection callbacks"},{"location":"getting-started/getting-started.html#limitations_1","text":"The OS selects the HCE service is based on AID. If the device have several applications implementing the same AID, the user will either be prompted to select the application to use or the system will choose the default application. To avoid the prompt: make sure to register com.assaabloy.mobilekeys.api.hce.HceService` as preferred service. To make the HceService work in background you have to make sure that the MobileKeysApi is initialized. This can be achieved by extending the the Android application and initialize the MobileKeysApi in the onCreate() callback.","title":"Limitations"},{"location":"getting-started/getting-started.html#device-eligibility","text":"Version 5.2 of the SDK introduced a way to check eligibility of the device the SDK is running on. The com.assaabloy.mobilekeys.api.DeviceEligibility contains information about working/non working features for the device. It also contains recommended RSSI settings for the device. This feature should be used before initializing the API and could be used to customize the user experience, e.g. turning off NFC on devices where NFC is known to fail.","title":"Device eligibility"},{"location":"getting-started/getting-started.html#device-status","text":"The class com.assaabloy.mobilekeys.api.util.DeviceStatus contains information about the Device's current status in regards to BLE and NFC. It can be asked about permissions, system supported features, and other things.","title":"Device Status"},{"location":"getting-started/logging.html","text":"The SDK uses SLF4J, Simple Logging Facade for Java , to provide logging. The SDK depends on the SLF4J API, the API jar must exist on the application classpath. To enable logging from the SDK classes, simply add a SLF4J implementation to your projects dependencies. If there is no SLF4J implementation on the application classpath, all logs from the SDK will be suppressed. There are several open source Android implementations of SLF4J available online. It's also quite easy to write your own implementation if you want full control over log tags etc. Logging is very useful during a development phase, but it's highly recommended to disable logging before releasing. Some of the DEBUG and INFO logs from the SDK contain sensitive information! Since version 6.6.0, release builds never produce log statements from within the SDK, regardless of project settings. All logging is disabled for release builds of the SDK. logback The SDK does not enable log output per default. SLF4J is dependant on one or more logger implementation available on the classpath. The Seos SDK team recommends logback-for-android by tony19 1 2 3 4 5 6 // Logging in debug builds debugCompile 'com.github.tony19:logback-android-core:1.1.1-6' debugCompile ( 'com.github.tony19:logback-android-classic:1.1.1-6' ) { // logback-android-classic depends on android.jar, exclude this. exclude group: 'com.google.android' , module: 'android' } Add this to src/main/assets/logback.xml: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 <configuration> <!-- log to normal LogCat --> <appender name= \"LOGCAT\" class= \"ch.qos.logback.classic.android.LogcatAppender\" > <tagEncoder> <pattern> %logger{12} </pattern> </tagEncoder> <encoder> <pattern> %line: %msg%n </pattern> </encoder> </appender> <!-- Write DEBUG (and higher-level) messages to the log --> <root level= \"TRACE\" > <appender-ref ref= \"LOGCAT\" /> </root> </configuration> Extracting log files from the SDK Please refer to the README.md file in the Seos Mobile SDK for Android Sample project included in the SDK package for how to extract logs from the SDK.","title":"Logging"},{"location":"getting-started/logging.html#logback","text":"The SDK does not enable log output per default. SLF4J is dependant on one or more logger implementation available on the classpath. The Seos SDK team recommends logback-for-android by tony19 1 2 3 4 5 6 // Logging in debug builds debugCompile 'com.github.tony19:logback-android-core:1.1.1-6' debugCompile ( 'com.github.tony19:logback-android-classic:1.1.1-6' ) { // logback-android-classic depends on android.jar, exclude this. exclude group: 'com.google.android' , module: 'android' } Add this to src/main/assets/logback.xml: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 <configuration> <!-- log to normal LogCat --> <appender name= \"LOGCAT\" class= \"ch.qos.logback.classic.android.LogcatAppender\" > <tagEncoder> <pattern> %logger{12} </pattern> </tagEncoder> <encoder> <pattern> %line: %msg%n </pattern> </encoder> </appender> <!-- Write DEBUG (and higher-level) messages to the log --> <root level= \"TRACE\" > <appender-ref ref= \"LOGCAT\" /> </root> </configuration>","title":"logback"},{"location":"getting-started/logging.html#extracting-log-files-from-the-sdk","text":"Please refer to the README.md file in the Seos Mobile SDK for Android Sample project included in the SDK package for how to extract logs from the SDK.","title":"Extracting log files from the SDK"},{"location":"getting-started/permissions.html","text":"The SDK contains a AndroidManifest.xml file with the permissions required. The permissions are as follows: Required to communicate with the Seos TSM: android.permission.INTERNET android.permission.ACCESS_NETWORK_STATE Required to communicate with readers through Bluetooth: android.permission.BLUETOOTH android.permission.BLUETOOTH_ADMIN android.permission.ACCESS_FINE_LOCATION Note: as of version 6.0 of Android the access coarse location permission is required to be able to read the hardware identifier of a reader while running in the background. The Seos Mobile SDK need this to differentiate between readers. More information here: Access to Hardware Identifier Required to communicate with readers through NFC: android.permission.NFC Removing permissions It is possible to prevent the manifest merging process to include a android library's permissions. For instance if you know your application will only make use of the bluetooth portion of the SDK and not the NFC, it makes sense to remove the NFC permission. To do this you declare the permission in your own manifest like so: 1 <uses-permission android:name= \"android.permission.NFC\" tools:node= \"remove\" />","title":"Removing permissions"},{"location":"getting-started/permissions.html#removing-permissions","text":"It is possible to prevent the manifest merging process to include a android library's permissions. For instance if you know your application will only make use of the bluetooth portion of the SDK and not the NFC, it makes sense to remove the NFC permission. To do this you declare the permission in your own manifest like so: 1 <uses-permission android:name= \"android.permission.NFC\" tools:node= \"remove\" />","title":"Removing permissions"},{"location":"getting-started/proguard.html","text":"Proguard is supported using the standard \"proguard-android.txt\" configuration. The bundled consumer proguard file covers the proguard configuration for the SDK but you might have to do configurations for your application. In your apps build.gradle file: 1 2 3 4 5 release { minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile ( 'proguard-android.txt' ), \"proguard.cfg\" } In case you use logback-android-core , add this to your proguard.cfg file: 1 2 3 4 5 6 7 8 # Add your Proguard configuration here # logging - keep class ch . qos . ** { * ; } - keep class org . slf4j . ** { * ; } - keepattributes * Annotation * - dontwarn javax . mail . ** - dontwarn javax . naming . Context - dontwarn javax . naming . InitialContext","title":"ProGuard"},{"location":"samples/remote-session.html","text":"Remote session With the remote session functionality you can implement various ways of accessing the Seos instance on the device. For e.g over HTTP. Below is sample code for how to use this functionality. Usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public static class RemoteSession { private static final String TAG = RemoteSession . class . getName (); private ReaderSession readerSession ; public RemoteSession () { } public ApduResult process ( ApduCommand command ) { if ( isOpen ()) { return readerSession . process ( command ); } Log . e ( TAG , \"ReaderSession is not open\" ); return null ; } public boolean open ( MobileKeys mobileKeys ) { if ( isOpen ()) { try { readerSession = mobileKeys . openReaderSession (); return true ; } catch ( MobileKeysException e ) { Log . e ( TAG , \"Error while opening remote session: \" , e ); } } Log . e ( TAG , \"Remote session is already open\" ); return false ; } public void close () { if ( readerSession != null ) { readerSession . close (); } } public boolean isOpen () { return readerSession != null && readerSession . isSessionOpen (); } }","title":"Remote session"},{"location":"samples/remote-session.html#remote-session","text":"With the remote session functionality you can implement various ways of accessing the Seos instance on the device. For e.g over HTTP. Below is sample code for how to use this functionality.","title":"Remote session"},{"location":"samples/remote-session.html#usage","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 public static class RemoteSession { private static final String TAG = RemoteSession . class . getName (); private ReaderSession readerSession ; public RemoteSession () { } public ApduResult process ( ApduCommand command ) { if ( isOpen ()) { return readerSession . process ( command ); } Log . e ( TAG , \"ReaderSession is not open\" ); return null ; } public boolean open ( MobileKeys mobileKeys ) { if ( isOpen ()) { try { readerSession = mobileKeys . openReaderSession (); return true ; } catch ( MobileKeysException e ) { Log . e ( TAG , \"Error while opening remote session: \" , e ); } } Log . e ( TAG , \"Remote session is already open\" ); return false ; } public void close () { if ( readerSession != null ) { readerSession . close (); } } public boolean isOpen () { return readerSession != null && readerSession . isSessionOpen (); } }","title":"Usage"},{"location":"seos-access-api-samples/accessing-remote-seos.html","text":"Reader session With the Seos Access API you can access another seos instance remotely. For e.g over HTTP. Below is sample code for how to use this functionality. Usage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // class fields HttpApduConnection httpApduConnection = new HttpApduConnection ( new HttpClientImpl ( true ), \"http://<Your local IPv4>:8090\" , \"XXXX-XXXX-XXXX-XXXX\" ); private final ScheduledExecutorService SCHEDULED_EXECUTOR_SERVICE = Executors . newSingleThreadScheduledExecutor ( new ThreadFactory () { @Override public Thread newThread ( Runnable r ) { return new Thread ( r , \"HTTP ApduConnection Thread\" ); } }); // inside method where we want to interact with the remote seos SCHEDULED_EXECUTOR_SERVICE . execute ( new Runnable () { @Override public void run () { try { httpApduConnection . createEndpoint (); } catch ( SeosTsmCommunicationException e ) { e . printStackTrace (); } } }); HttpApduConnection.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 package com.assaabloy.mobilekeys.api.simulator ; import com.assaabloy.mobilekeys.api.internal.http.HttpClient ; import com.assaabloy.mobilekeys.api.internal.http.HttpClientResponse ; import com.assaabloy.mobilekeys.api.internal.http.SeosTsmCommunicationException ; import com.assaabloy.seos.access.ApduConnection ; import com.assaabloy.seos.access.apdu.ApduCommand ; import com.assaabloy.seos.access.apdu.ApduResult ; import org.slf4j.Logger ; import org.slf4j.LoggerFactory ; import java.io.IOException ; public class HttpApduConnection implements ApduConnection { private static final Logger LOGGER = LoggerFactory . getLogger ( HttpApduConnection . class ); private static final String ENDPOINT_PATH = \"seos-simulator/endpoint\" ; private static final String APPLICATION_ID = \"AAMK\" ; private static final String APP_STARTUP_PATH = \"applicationStartup\" ; private static final String SETUP_PATH = \"seos-simulator/setup\" ; private static final String SESSION_PATH = \"seos-simulator/session\" ; private static final String OPEN_PATH = \"open\" ; private static final String CLOSE_PATH = \"close\" ; private static final String APDU_PATH = \"apdu\" ; private final HttpClient httpClient ; private final String host ; private final String invitationCode ; private String currentSessionId ; private boolean isOpen ; public HttpApduConnection ( HttpClient httpClient , String host , String invitationCode ) { this . httpClient = httpClient ; this . host = host ; this . invitationCode = invitationCode ; } public void createEndpoint () throws SeosTsmCommunicationException { HttpClientResponse httpClientResponse = httpClient . sendRequest ( host + \"/\" + SETUP_PATH + \"/\" + APPLICATION_ID + \"/\" + invitationCode , \"text/plain\" , \"\" , HttpClient . HttpMethod . POST ); LOGGER . debug ( \"Status: {} Body: {}\" , httpClientResponse . statusCode (), httpClientResponse . body ()); } public void updateEndpoint () throws SeosTsmCommunicationException { HttpClientResponse httpClientResponse = httpClient . sendRequest ( host + \"/\" + ENDPOINT_PATH + \"/\" + invitationCode , \"text/plain\" , \"\" , HttpClient . HttpMethod . POST ); LOGGER . debug ( \"Status: {} Body: {}\" , httpClientResponse . statusCode (), httpClientResponse . body ()); } public void applicationStartup () throws SeosTsmCommunicationException { HttpClientResponse httpClientResponse = httpClient . sendRequest ( host + \"/\" + ENDPOINT_PATH + \"/\" + invitationCode + \"/\" + APP_STARTUP_PATH , \"text/plain\" , \"\" , HttpClient . HttpMethod . POST ); LOGGER . debug ( \"Status: {} Body: {}\" , httpClientResponse . statusCode (), httpClientResponse . body ()); } public void open () throws SeosTsmCommunicationException { HttpClientResponse httpClientResponse = httpClient . sendRequest ( host + \"/\" + SESSION_PATH + \"/\" + OPEN_PATH + \"/\" + invitationCode , \"text/plain\" , \"\" , HttpClient . HttpMethod . POST ); currentSessionId = httpClientResponse . body (); LOGGER . debug ( \"Status: {} Body: {}\" , httpClientResponse . statusCode (), httpClientResponse . body ()); if ( httpClientResponse . isSuccessful ()) { isOpen = true ; } } public void close () throws SeosTsmCommunicationException { HttpClientResponse httpClientResponse = httpClient . sendRequest ( host + \"/\" + SESSION_PATH + \"/\" + CLOSE_PATH + \"/\" + currentSessionId , \"text/plain\" , \"\" , HttpClient . HttpMethod . POST ); LOGGER . debug ( \"Status: {} Body: {}\" , httpClientResponse . statusCode (), httpClientResponse . body ()); currentSessionId = null ; } @Override public ApduResult send ( ApduCommand apduCommand ) throws IOException { try { HttpClientResponse httpClientResponse = httpClient . sendRequest ( host + \"/\" + SESSION_PATH + \"/\" + currentSessionId + \"/\" + APDU_PATH + \"/\" + apduCommand . toHexString (), \"text/plain\" , \"\" , HttpClient . HttpMethod . POST ); return ApduResult . parseHexString ( httpClientResponse . body ()); } catch ( SeosTsmCommunicationException e ) { throw new IOException ( e ); } } @Override public boolean requiresSelectAid () { return true ; } }","title":"Accessing a Seos over HTTP"},{"location":"seos-access-api-samples/accessing-remote-seos.html#reader-session","text":"With the Seos Access API you can access another seos instance remotely. For e.g over HTTP. Below is sample code for how to use this functionality.","title":"Reader session"},{"location":"seos-access-api-samples/accessing-remote-seos.html#usage","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // class fields HttpApduConnection httpApduConnection = new HttpApduConnection ( new HttpClientImpl ( true ), \"http://<Your local IPv4>:8090\" , \"XXXX-XXXX-XXXX-XXXX\" ); private final ScheduledExecutorService SCHEDULED_EXECUTOR_SERVICE = Executors . newSingleThreadScheduledExecutor ( new ThreadFactory () { @Override public Thread newThread ( Runnable r ) { return new Thread ( r , \"HTTP ApduConnection Thread\" ); } }); // inside method where we want to interact with the remote seos SCHEDULED_EXECUTOR_SERVICE . execute ( new Runnable () { @Override public void run () { try { httpApduConnection . createEndpoint (); } catch ( SeosTsmCommunicationException e ) { e . printStackTrace (); } } }); HttpApduConnection.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 package com.assaabloy.mobilekeys.api.simulator ; import com.assaabloy.mobilekeys.api.internal.http.HttpClient ; import com.assaabloy.mobilekeys.api.internal.http.HttpClientResponse ; import com.assaabloy.mobilekeys.api.internal.http.SeosTsmCommunicationException ; import com.assaabloy.seos.access.ApduConnection ; import com.assaabloy.seos.access.apdu.ApduCommand ; import com.assaabloy.seos.access.apdu.ApduResult ; import org.slf4j.Logger ; import org.slf4j.LoggerFactory ; import java.io.IOException ; public class HttpApduConnection implements ApduConnection { private static final Logger LOGGER = LoggerFactory . getLogger ( HttpApduConnection . class ); private static final String ENDPOINT_PATH = \"seos-simulator/endpoint\" ; private static final String APPLICATION_ID = \"AAMK\" ; private static final String APP_STARTUP_PATH = \"applicationStartup\" ; private static final String SETUP_PATH = \"seos-simulator/setup\" ; private static final String SESSION_PATH = \"seos-simulator/session\" ; private static final String OPEN_PATH = \"open\" ; private static final String CLOSE_PATH = \"close\" ; private static final String APDU_PATH = \"apdu\" ; private final HttpClient httpClient ; private final String host ; private final String invitationCode ; private String currentSessionId ; private boolean isOpen ; public HttpApduConnection ( HttpClient httpClient , String host , String invitationCode ) { this . httpClient = httpClient ; this . host = host ; this . invitationCode = invitationCode ; } public void createEndpoint () throws SeosTsmCommunicationException { HttpClientResponse httpClientResponse = httpClient . sendRequest ( host + \"/\" + SETUP_PATH + \"/\" + APPLICATION_ID + \"/\" + invitationCode , \"text/plain\" , \"\" , HttpClient . HttpMethod . POST ); LOGGER . debug ( \"Status: {} Body: {}\" , httpClientResponse . statusCode (), httpClientResponse . body ()); } public void updateEndpoint () throws SeosTsmCommunicationException { HttpClientResponse httpClientResponse = httpClient . sendRequest ( host + \"/\" + ENDPOINT_PATH + \"/\" + invitationCode , \"text/plain\" , \"\" , HttpClient . HttpMethod . POST ); LOGGER . debug ( \"Status: {} Body: {}\" , httpClientResponse . statusCode (), httpClientResponse . body ()); } public void applicationStartup () throws SeosTsmCommunicationException { HttpClientResponse httpClientResponse = httpClient . sendRequest ( host + \"/\" + ENDPOINT_PATH + \"/\" + invitationCode + \"/\" + APP_STARTUP_PATH , \"text/plain\" , \"\" , HttpClient . HttpMethod . POST ); LOGGER . debug ( \"Status: {} Body: {}\" , httpClientResponse . statusCode (), httpClientResponse . body ()); } public void open () throws SeosTsmCommunicationException { HttpClientResponse httpClientResponse = httpClient . sendRequest ( host + \"/\" + SESSION_PATH + \"/\" + OPEN_PATH + \"/\" + invitationCode , \"text/plain\" , \"\" , HttpClient . HttpMethod . POST ); currentSessionId = httpClientResponse . body (); LOGGER . debug ( \"Status: {} Body: {}\" , httpClientResponse . statusCode (), httpClientResponse . body ()); if ( httpClientResponse . isSuccessful ()) { isOpen = true ; } } public void close () throws SeosTsmCommunicationException { HttpClientResponse httpClientResponse = httpClient . sendRequest ( host + \"/\" + SESSION_PATH + \"/\" + CLOSE_PATH + \"/\" + currentSessionId , \"text/plain\" , \"\" , HttpClient . HttpMethod . POST ); LOGGER . debug ( \"Status: {} Body: {}\" , httpClientResponse . statusCode (), httpClientResponse . body ()); currentSessionId = null ; } @Override public ApduResult send ( ApduCommand apduCommand ) throws IOException { try { HttpClientResponse httpClientResponse = httpClient . sendRequest ( host + \"/\" + SESSION_PATH + \"/\" + currentSessionId + \"/\" + APDU_PATH + \"/\" + apduCommand . toHexString (), \"text/plain\" , \"\" , HttpClient . HttpMethod . POST ); return ApduResult . parseHexString ( httpClientResponse . body ()); } catch ( SeosTsmCommunicationException e ) { throw new IOException ( e ); } } @Override public boolean requiresSelectAid () { return true ; } }","title":"Usage"},{"location":"seos-access-api-samples/ake-session-setup.html","text":"Using AKE to authenticate to a card requires an active session to the Terminal. The following example code sets up basic privacy keys and a session to the Terminal using the MobileKeysSeosProvider API. A second MobileKeysSeosProvider is then required to create the APDU connection session to the Card. The code has been tested and works using the example keys below the code example. Overview of the code Setup privacy keys using the test vectors (same as in the json keys below) Open a session to the Mobile Access SDK default MobileKeysSeosProvider This instance of Seos is expected to have the \"Terminal side test key\" Setup the custom Card Connection (not provided by the example code) This instance of Seos is expected to have the \"Card side test key\" Establish a connection to the Card by utilizing the already connected Terminal Connection MobileKeysSeosProvider Read Tag FF00 from the Card Close the connection Java sample code for setting up a Card session 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 private void doTerminalAke ( SeosConnection cardSeosConnection ) throws MobileKeysException { Session session = null ; try { //replace this with your reference of the MobileKeys object MobileKeys mobileKeys = MobileKeysImpl . this ; //openSeosAccessApiSession() opens a session to the local seos on device session = mobileKeys . openSeosAccessApiSession ( new SessionParameters . Builder () . setPrivacyKeyset ( new PlainPrivacyKeyset ( KeyNumber . KEY_0 , HexUtils . toBytes ( \"Terminal privacy enc key here\" ), HexUtils . toBytes ( \"Terminal privacy mac key here\" ))) //ADF from iOS SDK documentation has no authentication but you should put the appropriate values here to enable local secure messaging . setAuthenticationKeyset ( new PlainAuthenticationKeyset ( KeyNumber . KEY_1 , false , HexUtils . toBytes ( \"Appropriate terminal auth enc key here\" ), HexUtils . toBytes ( \"Appropriate terminal auth mac key here\" ))) . setSelection ( Select . selectAdf ( new Oid ( HexUtils . toBytes ( \"OID of terminal ADF with AKE keyset object\" )))) . build ()); SessionParameters cardSessionParameters = new SessionParameters . Builder () . setPrivacyKeyset ( new PlainPrivacyKeyset ( KeyNumber . KEY_0 , HexUtils . toBytes ( \"Card privacy enc key here\" ), HexUtils . toBytes ( \"Card privacy mac key here\" ))) //You don't need to set an authentication keyset here as this is replaced by AKE. . setSelection ( Select . selectAdf ( new Oid ( HexUtils . toBytes ( \"OID of card ADF with AKE keyset object\" )))) . build (); CommandResult < Session > commandResult = session . execute ( Commands . authenticatedKeyExchangeInTerminalMode ( new TerminalAkeParameters . Builder () . setCardSessionParameters ( cardSessionParameters ) . setCardGlobalKey ( false ) . setCardKeyNumber ( KeyNumber . KEY_4 ) . setTerminalGlobalKey ( false ) . setTerminalKeyNumber ( KeyNumber . KEY_4 ) . setCardSeosConnection ( cardSeosConnection ) . build () )); if ( commandResult . hasResponseData ()) { Session cardSession = commandResult . responseData (); //We are ready to read stuff from cardSession } else { //failed } } catch ( SessionException e ) { throw new IllegalStateException ( \"Failed to establish session\" , e ); } finally { if ( session != null ) { session . close (); } } } Terminal side test key Terminal test key with AKE data on KEY 4. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 { \"endpointId\" : 3342568 , \"seosData\" : { \"oid\" : \"0202020202020202\" , \"diversifier\" : \"049668A1761B80\" , \"accessListPermissions\" : { \"getPermissions\" : [], \"putPermissions\" : [] }, \"keysetObjectAccessGroups\" : [{ \"putPermissions\" : [], \"keysetObjects\" : [{ \"type\" : \"PRIVACY\" , \"contact\" : true , \"contactless\" : true , \"keyData\" : { \"type\" : \"VALUES\" , \"macKey\" : \"8aa83bf8cbda10620bc1bf19fbb6cd58\" , \"encKey\" : \"5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A\" }, \"keyNumber\" : \"KEY_0\" }, { \"type\" : \"AUTHENTICATION\" , \"contact\" : true , \"contactless\" : true , \"optional\" : false , \"keyData\" : { \"type\" : \"VALUES\" , \"macKey\" : \"F5582EADD895225DC71D080E19338A25\" , \"encKey\" : \"E0F75D03506A735C93DF39113D18532F\" }, \"keyNumber\" : \"KEY_1\" }, { \"type\" : \"AUTHENTICATION\" , \"contact\" : true , \"contactless\" : true , \"optional\" : false , \"keyData\" : { \"type\" : \"VALUES\" , \"macKey\" : \"11bdb88e534ff02ca4e77e858dccd37e\" , \"encKey\" : \"269c555f45bf3ee0095ea1e385713131\" }, \"keyNumber\" : \"KEY_2\" }, { \"type\" : \"AKE\" , \"keyNumber\" : \"KEY_4\" , \"contact\" : true , \"contactless\" : true , \"keyData\" : { \"type\" : \"VALUES\" , \"privatePoint\" : \"79578FC9F2A7CD688D86E3FA272489B7CF2CF7A5DB6589D0F320CC43D15612A3\" }, \"certificate\" : \"7F21819A7F4E54420211227F494D06082A8648CE3D030107864104B95C24D84E3F88652B2984C737771126F92809E23E08AA70376683C6035EAEB0A89746181E1F956BBF8CD8D21883E37A0D9FAE452732EBDD578E521900AC2BF35F3740AB03CE6554C4774847DD703439488D632E75E7A00D86CB61A9F4A25CACAA89CE5C9820ABDF0F69DB6A43967C92CC66662045D0B178DDABF309D1195464A3C89E\" , \"ifdRootPublicKey\" : \"04B16BA7C60B2811FB8BAD86400189BBB695EA2D9801D610F0A125CBEC6D86F96ECF3EE259A4FF27D7DABF294ADF27F1DB507A93B5DB33BA666E75D1AD46668EF8\" , \"terminalPermissions\" : [{ \"type\" : \"INTERFACE\" , \"value\" : \"ALWAYS_ACCESS\" }] }] }], \"metadata\" : { \"label\" : \"Terminal Seos\" , \"issuer\" : \"01\" , \"type\" : \"LEGACY\" , \"permissions\" : { \"getPermissions\" : [], \"putPermissions\" : [] }, \"additionalFields\" :[] }, \"dataObjectAccessGroups\" : [{ \"permissions\" : { \"getPermissions\" : [{ \"type\" : \"KEY\" , \"keyNumber\" : \"KEY_1\" }, { \"type\" : \"KEY\" , \"keyNumber\" : \"KEY_4\" }], \"putPermissions\" : [{ \"type\" : \"KEY\" , \"keyNumber\" : \"KEY_4\" }] }, \"dataObjects\" : [{ \"tag\" : \"FF00\" , \"data\" : \"3062810100A41D300981029400040301000004103AC3FD8364C1A44A219C23DFC144C715A50B3009810294000403010000A609810294000403010000A7128510CDE93D03FF1A1BDE9829F194BE39074AA9120410325FA33B87684001F9E5F9D0C4BA01A20500\" }] }] } } Card side test key Test key with AKE data on KEY 4. Tag FF00 is readable and writeable after authenticating using the AKE key to the Terminal key above. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 { \"endpointId\" : 3342274 , \"seosData\" : { \"oid\" : \"0202020202020202\" , \"diversifier\" : \"049668A1761B80\" , \"accessListPermissions\" : { \"getPermissions\" : [], \"putPermissions\" : [] }, \"keysetObjectAccessGroups\" : [{ \"putPermissions\" : [], \"keysetObjects\" : [{ \"type\" : \"PRIVACY\" , \"contact\" : true , \"contactless\" : true , \"keyData\" : { \"type\" : \"VALUES\" , \"macKey\" : \"8aa83bf8cbda10620bc1bf19fbb6cd58\" , \"encKey\" : \"5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A\" }, \"keyNumber\" : \"KEY_0\" }, { \"type\" : \"AUTHENTICATION\" , \"contact\" : true , \"contactless\" : true , \"optional\" : false , \"keyData\" : { \"type\" : \"VALUES\" , \"macKey\" : \"F5582EADD895225DC71D080E19338A25\" , \"encKey\" : \"E0F75D03506A735C93DF39113D18532F\" }, \"keyNumber\" : \"KEY_1\" }, { \"type\" : \"AUTHENTICATION\" , \"contact\" : true , \"contactless\" : true , \"optional\" : false , \"keyData\" : { \"type\" : \"VALUES\" , \"macKey\" : \"11bdb88e534ff02ca4e77e858dccd37e\" , \"encKey\" : \"269c555f45bf3ee0095ea1e385713131\" }, \"keyNumber\" : \"KEY_2\" }, { \"type\" : \"AKE\" , \"keyNumber\" : \"KEY_4\" , \"contact\" : true , \"contactless\" : true , \"keyData\" : { \"type\" : \"VALUES\" , \"privatePoint\" : \"31B436FDBDA5531273F1068570608CBF084BB7D8B67357D9C575F1612A10BA13\" }, \"certificate\" : \"7F21819A7F4E54420233447F494D06082A8648CE3D0301078641041025822DD4EB00690A23FFD0A793DB0B6131C166226C40D921815CEC3C62C26836234FE1592A5F28DBF6D6188CB021C8494699614ABC6B14CC27AABFDD21D0475F37403BC992EBECEF66F2147D92C4AEFD2E5C276F23D3FFA700628FBE49B90C998686C184A948C6542FD8B68B156B044543C2B5BA7E492CF063F2F1596C6E5566CEE5\" , \"ifdRootPublicKey\" : \"04DFB451969695155780105573C9AEA05ADE67E5242ECAFF959AE81FC7F7B52247030BCF9189524138DDB98F3082DA101AE607C1C3BDB3DA1A874A0D6E4A82A737\" , \"terminalPermissions\" : [{ \"type\" : \"INTERFACE\" , \"value\" : \"ALWAYS_ACCESS\" }] }] }], \"metadata\" : { \"label\" : \"Card Seos\" , \"issuer\" : \"01\" , \"type\" : \"LEGACY\" , \"permissions\" : { \"getPermissions\" : [], \"putPermissions\" : [] }, \"additionalFields\" :[] }, \"dataObjectAccessGroups\" : [{ \"permissions\" : { \"getPermissions\" : [{ \"type\" : \"KEY\" , \"keyNumber\" : \"KEY_1\" }, { \"type\" : \"KEY\" , \"keyNumber\" : \"KEY_4\" }], \"putPermissions\" : [{ \"type\" : \"KEY\" , \"keyNumber\" : \"KEY_4\" }] }, \"dataObjects\" : [{ \"tag\" : \"FF00\" , \"data\" : \"3062810100A41D300981029400040301000004103AC3FD8364C1A44A219C23DFC144C715A50B3009810294000403010000A609810294000403010000A7128510CDE93D03FF1A1BDE9829F194BE39074AA9120410325FA33B87684001F9E5F9D0C4BA01A20500\" }] }] } }","title":"AKE session setup"},{"location":"seos-access-api-samples/ake-session-setup.html#overview-of-the-code","text":"Setup privacy keys using the test vectors (same as in the json keys below) Open a session to the Mobile Access SDK default MobileKeysSeosProvider This instance of Seos is expected to have the \"Terminal side test key\" Setup the custom Card Connection (not provided by the example code) This instance of Seos is expected to have the \"Card side test key\" Establish a connection to the Card by utilizing the already connected Terminal Connection MobileKeysSeosProvider Read Tag FF00 from the Card Close the connection","title":"Overview of the code"},{"location":"seos-access-api-samples/ake-session-setup.html#java-sample-code-for-setting-up-a-card-session","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 private void doTerminalAke ( SeosConnection cardSeosConnection ) throws MobileKeysException { Session session = null ; try { //replace this with your reference of the MobileKeys object MobileKeys mobileKeys = MobileKeysImpl . this ; //openSeosAccessApiSession() opens a session to the local seos on device session = mobileKeys . openSeosAccessApiSession ( new SessionParameters . Builder () . setPrivacyKeyset ( new PlainPrivacyKeyset ( KeyNumber . KEY_0 , HexUtils . toBytes ( \"Terminal privacy enc key here\" ), HexUtils . toBytes ( \"Terminal privacy mac key here\" ))) //ADF from iOS SDK documentation has no authentication but you should put the appropriate values here to enable local secure messaging . setAuthenticationKeyset ( new PlainAuthenticationKeyset ( KeyNumber . KEY_1 , false , HexUtils . toBytes ( \"Appropriate terminal auth enc key here\" ), HexUtils . toBytes ( \"Appropriate terminal auth mac key here\" ))) . setSelection ( Select . selectAdf ( new Oid ( HexUtils . toBytes ( \"OID of terminal ADF with AKE keyset object\" )))) . build ()); SessionParameters cardSessionParameters = new SessionParameters . Builder () . setPrivacyKeyset ( new PlainPrivacyKeyset ( KeyNumber . KEY_0 , HexUtils . toBytes ( \"Card privacy enc key here\" ), HexUtils . toBytes ( \"Card privacy mac key here\" ))) //You don't need to set an authentication keyset here as this is replaced by AKE. . setSelection ( Select . selectAdf ( new Oid ( HexUtils . toBytes ( \"OID of card ADF with AKE keyset object\" )))) . build (); CommandResult < Session > commandResult = session . execute ( Commands . authenticatedKeyExchangeInTerminalMode ( new TerminalAkeParameters . Builder () . setCardSessionParameters ( cardSessionParameters ) . setCardGlobalKey ( false ) . setCardKeyNumber ( KeyNumber . KEY_4 ) . setTerminalGlobalKey ( false ) . setTerminalKeyNumber ( KeyNumber . KEY_4 ) . setCardSeosConnection ( cardSeosConnection ) . build () )); if ( commandResult . hasResponseData ()) { Session cardSession = commandResult . responseData (); //We are ready to read stuff from cardSession } else { //failed } } catch ( SessionException e ) { throw new IllegalStateException ( \"Failed to establish session\" , e ); } finally { if ( session != null ) { session . close (); } } }","title":"Java sample code for setting up a Card session"},{"location":"seos-access-api-samples/ake-session-setup.html#terminal-side-test-key","text":"Terminal test key with AKE data on KEY 4. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 { \"endpointId\" : 3342568 , \"seosData\" : { \"oid\" : \"0202020202020202\" , \"diversifier\" : \"049668A1761B80\" , \"accessListPermissions\" : { \"getPermissions\" : [], \"putPermissions\" : [] }, \"keysetObjectAccessGroups\" : [{ \"putPermissions\" : [], \"keysetObjects\" : [{ \"type\" : \"PRIVACY\" , \"contact\" : true , \"contactless\" : true , \"keyData\" : { \"type\" : \"VALUES\" , \"macKey\" : \"8aa83bf8cbda10620bc1bf19fbb6cd58\" , \"encKey\" : \"5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A\" }, \"keyNumber\" : \"KEY_0\" }, { \"type\" : \"AUTHENTICATION\" , \"contact\" : true , \"contactless\" : true , \"optional\" : false , \"keyData\" : { \"type\" : \"VALUES\" , \"macKey\" : \"F5582EADD895225DC71D080E19338A25\" , \"encKey\" : \"E0F75D03506A735C93DF39113D18532F\" }, \"keyNumber\" : \"KEY_1\" }, { \"type\" : \"AUTHENTICATION\" , \"contact\" : true , \"contactless\" : true , \"optional\" : false , \"keyData\" : { \"type\" : \"VALUES\" , \"macKey\" : \"11bdb88e534ff02ca4e77e858dccd37e\" , \"encKey\" : \"269c555f45bf3ee0095ea1e385713131\" }, \"keyNumber\" : \"KEY_2\" }, { \"type\" : \"AKE\" , \"keyNumber\" : \"KEY_4\" , \"contact\" : true , \"contactless\" : true , \"keyData\" : { \"type\" : \"VALUES\" , \"privatePoint\" : \"79578FC9F2A7CD688D86E3FA272489B7CF2CF7A5DB6589D0F320CC43D15612A3\" }, \"certificate\" : \"7F21819A7F4E54420211227F494D06082A8648CE3D030107864104B95C24D84E3F88652B2984C737771126F92809E23E08AA70376683C6035EAEB0A89746181E1F956BBF8CD8D21883E37A0D9FAE452732EBDD578E521900AC2BF35F3740AB03CE6554C4774847DD703439488D632E75E7A00D86CB61A9F4A25CACAA89CE5C9820ABDF0F69DB6A43967C92CC66662045D0B178DDABF309D1195464A3C89E\" , \"ifdRootPublicKey\" : \"04B16BA7C60B2811FB8BAD86400189BBB695EA2D9801D610F0A125CBEC6D86F96ECF3EE259A4FF27D7DABF294ADF27F1DB507A93B5DB33BA666E75D1AD46668EF8\" , \"terminalPermissions\" : [{ \"type\" : \"INTERFACE\" , \"value\" : \"ALWAYS_ACCESS\" }] }] }], \"metadata\" : { \"label\" : \"Terminal Seos\" , \"issuer\" : \"01\" , \"type\" : \"LEGACY\" , \"permissions\" : { \"getPermissions\" : [], \"putPermissions\" : [] }, \"additionalFields\" :[] }, \"dataObjectAccessGroups\" : [{ \"permissions\" : { \"getPermissions\" : [{ \"type\" : \"KEY\" , \"keyNumber\" : \"KEY_1\" }, { \"type\" : \"KEY\" , \"keyNumber\" : \"KEY_4\" }], \"putPermissions\" : [{ \"type\" : \"KEY\" , \"keyNumber\" : \"KEY_4\" }] }, \"dataObjects\" : [{ \"tag\" : \"FF00\" , \"data\" : \"3062810100A41D300981029400040301000004103AC3FD8364C1A44A219C23DFC144C715A50B3009810294000403010000A609810294000403010000A7128510CDE93D03FF1A1BDE9829F194BE39074AA9120410325FA33B87684001F9E5F9D0C4BA01A20500\" }] }] } }","title":"Terminal side test key"},{"location":"seos-access-api-samples/ake-session-setup.html#card-side-test-key","text":"Test key with AKE data on KEY 4. Tag FF00 is readable and writeable after authenticating using the AKE key to the Terminal key above. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 { \"endpointId\" : 3342274 , \"seosData\" : { \"oid\" : \"0202020202020202\" , \"diversifier\" : \"049668A1761B80\" , \"accessListPermissions\" : { \"getPermissions\" : [], \"putPermissions\" : [] }, \"keysetObjectAccessGroups\" : [{ \"putPermissions\" : [], \"keysetObjects\" : [{ \"type\" : \"PRIVACY\" , \"contact\" : true , \"contactless\" : true , \"keyData\" : { \"type\" : \"VALUES\" , \"macKey\" : \"8aa83bf8cbda10620bc1bf19fbb6cd58\" , \"encKey\" : \"5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A\" }, \"keyNumber\" : \"KEY_0\" }, { \"type\" : \"AUTHENTICATION\" , \"contact\" : true , \"contactless\" : true , \"optional\" : false , \"keyData\" : { \"type\" : \"VALUES\" , \"macKey\" : \"F5582EADD895225DC71D080E19338A25\" , \"encKey\" : \"E0F75D03506A735C93DF39113D18532F\" }, \"keyNumber\" : \"KEY_1\" }, { \"type\" : \"AUTHENTICATION\" , \"contact\" : true , \"contactless\" : true , \"optional\" : false , \"keyData\" : { \"type\" : \"VALUES\" , \"macKey\" : \"11bdb88e534ff02ca4e77e858dccd37e\" , \"encKey\" : \"269c555f45bf3ee0095ea1e385713131\" }, \"keyNumber\" : \"KEY_2\" }, { \"type\" : \"AKE\" , \"keyNumber\" : \"KEY_4\" , \"contact\" : true , \"contactless\" : true , \"keyData\" : { \"type\" : \"VALUES\" , \"privatePoint\" : \"31B436FDBDA5531273F1068570608CBF084BB7D8B67357D9C575F1612A10BA13\" }, \"certificate\" : \"7F21819A7F4E54420233447F494D06082A8648CE3D0301078641041025822DD4EB00690A23FFD0A793DB0B6131C166226C40D921815CEC3C62C26836234FE1592A5F28DBF6D6188CB021C8494699614ABC6B14CC27AABFDD21D0475F37403BC992EBECEF66F2147D92C4AEFD2E5C276F23D3FFA700628FBE49B90C998686C184A948C6542FD8B68B156B044543C2B5BA7E492CF063F2F1596C6E5566CEE5\" , \"ifdRootPublicKey\" : \"04DFB451969695155780105573C9AEA05ADE67E5242ECAFF959AE81FC7F7B52247030BCF9189524138DDB98F3082DA101AE607C1C3BDB3DA1A874A0D6E4A82A737\" , \"terminalPermissions\" : [{ \"type\" : \"INTERFACE\" , \"value\" : \"ALWAYS_ACCESS\" }] }] }], \"metadata\" : { \"label\" : \"Card Seos\" , \"issuer\" : \"01\" , \"type\" : \"LEGACY\" , \"permissions\" : { \"getPermissions\" : [], \"putPermissions\" : [] }, \"additionalFields\" :[] }, \"dataObjectAccessGroups\" : [{ \"permissions\" : { \"getPermissions\" : [{ \"type\" : \"KEY\" , \"keyNumber\" : \"KEY_1\" }, { \"type\" : \"KEY\" , \"keyNumber\" : \"KEY_4\" }], \"putPermissions\" : [{ \"type\" : \"KEY\" , \"keyNumber\" : \"KEY_4\" }] }, \"dataObjects\" : [{ \"tag\" : \"FF00\" , \"data\" : \"3062810100A41D300981029400040301000004103AC3FD8364C1A44A219C23DFC144C715A50B3009810294000403010000A609810294000403010000A7128510CDE93D03FF1A1BDE9829F194BE39074AA9120410325FA33B87684001F9E5F9D0C4BA01A20500\" }] }] } }","title":"Card side test key"},{"location":"seos-access-api-samples/credential-for-test.html","text":"This is the specific test credential used with the above test code that can be issued via a POST to the TSM mobile-keys-management/credential/ endpoint The endpoint id here is 4106051 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 { \"endpointId\" : 4106051 , \"seosData\" : { \"oid\" : \"0202020202020202\" , \"diversifier\" : \"\" , \"accessListPermissions\" : { \"getPermissions\" : [], \"putPermissions\" : [] }, \"keysetObjectAccessGroups\" : [ { \"Comment\" : \"Key Zero is the privacy key\" , \"putPermissions\" : [], \"keysetObjects\" : [ { \"type\" : \"PRIVACY\" , \"contact\" : true , \"contactless\" : true , \"keyData\" : { \"type\" : \"VALUES\" , \"macKey\" : \"8AA83BF8CBDA10620BC1BF19FBB6CD58\" , \"encKey\" : \"5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A\" }, \"keyNumber\" : \"KEY_0\" }, { \"Comment\" : \"Key One is the Auth key from CONTACT only\" , \"type\" : \"AUTHENTICATION\" , \"contact\" : true , \"contactless\" : false , \"optional\" : false , \"keyData\" : { \"type\" : \"VALUES\" , \"macKey\" : \"F5582EADD895225DC71D080E19338A25\" , \"encKey\" : \"E0F75D03506A735C93DF39113D18532F\" }, \"keyNumber\" : \"KEY_1\" }, { \"Comment\" : \"Key Two is the Auth key from CONTACTLESS only\" , \"type\" : \"AUTHENTICATION\" , \"contact\" : false , \"contactless\" : true , \"optional\" : false , \"keyData\" : { \"type\" : \"VALUES\" , \"macKey\" : \"11BDB88E534FF02CA4E77E858DCCD37E\" , \"encKey\" : \"269C555F45BF3EE0095EA1E385713131\" }, \"keyNumber\" : \"KEY_2\" } ] } ], \"metadata\" : { \"label\" : \"Seos test vectors - Plain\" , \"issuer\" : \"01\" , \"type\" : \"LEGACY\" , \"permissions\" : { \"getPermissions\" : [ { \"type\" : \"INTERFACE\" , \"value\" : \"ALWAYS_ACCESS\" } ], \"putPermissions\" : [] }, \"additionalFields\" : [] }, \"dataObjectAccessGroups\" : [ { \"Comment\" : \"FF01 is Readable from CONTACT only (key1), writable from CONTACTLESS (key2)\" , \"permissions\" : { \"getPermissions\" : [ { \"type\" : \"KEY\" , \"keyNumber\" : \"KEY_1\" } ], \"putPermissions\" : [ { \"type\" : \"KEY\" , \"keyNumber\" : \"KEY_2\" } ] }, \"dataObjects\" : [ { \"tag\" : \"FF01\" , \"data\" : \"040411223344\" } ] } ] } }","title":"Credential for test"},{"location":"seos-access-api-samples/read-adf-metadata.html","text":"This sample code reads the metadata from the passed MobileKey object. Assuming the correct permissions have been configured on the key. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 private Metadata getMetadataFromKey ( MobileKey key ) throws MobileKeysException { MobileKeys mobileKeys = MobileKeysApi . getInstance (). getMobileKeys (); Session session = null ; try { SessionParameters . Builder builder = new SessionParameters . Builder () . setSelection ( Select . extendedSelectAdf ( key . getIdentifier (). oid ())) . setPrivacyKeyset ( new DisabledPrivacyKeyset ( KeyNumber . KEY_0 )); session = mobileKeys . openSeosAccessApiSession ( builder . build ()); CommandResult < Metadata > metadataResult = session . execute ( Commands . getSeosObject ( SeosObjects . METADATA )); if ( metadataResult . status () != CommandResult . Status . SUCCESS ) { throw new MobileKeysException ( InternalErrorCode . SECURE_ELEMENT_ERROR ); } return metadataResult . responseData (); } catch ( SessionException se ) { throw new MobileKeysException ( InternalErrorCode . SECURE_ELEMENT_ERROR , se ); } finally { if ( session != null ) { session . close (); } } }","title":"Read ADF metadata"},{"location":"seos-access-api-samples/read-write-tags-on-adf.html","text":"This method reads and writes data to tag 0xFF01 using no encryption keys 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 private void readWriteToTag ( MobileKey key ) throws MobileKeysException { MobileKeys mobileKeys = MobileKeysApi . getInstance (). getMobileKeys (); SeosTag tag = new SeosTag ( 0xFF01 ); byte [] data = generateData ( 16 ); Session session = null ; try { SessionParameters . Builder builder = new SessionParameters . Builder () . setSelection ( Select . extendedSelectAdf ( key . getIdentifier (). oid ())) . setPrivacyKeyset ( new DisabledPrivacyKeyset ( KeyNumber . KEY_0 )); session = mobileKeys . openSeosAccessApiSession ( builder . build ()); CommandResult < Void > putDataResult = session . execute ( Commands . putSeosObject ( new DataObject ( tag , data ))); if ( putDataResult . status () != CommandResult . Status . SUCCESS ) { throw new MobileKeysException ( InternalErrorCode . SECURE_ELEMENT_ERROR ); } CommandResult < DataObject > getDataResult = session . execute ( Commands . getSeosObject ( SeosObjects . dataObject ( tag ))); if ( getDataResult . status () != CommandResult . Status . SUCCESS || Arrays . equals ( getDataResult . responseData (). seosData (), data )) { throw new MobileKeysException ( InternalErrorCode . SECURE_ELEMENT_ERROR ); } LOGGER . debug ( \"Got object from FF01 {}\" , getDataResult . toHex ()); } catch ( SessionException se ) { throw new MobileKeysException ( InternalErrorCode . SECURE_ELEMENT_ERROR , se ); } finally { if ( session != null ) { session . close (); } } } private byte [] generateData ( int size ) { byte [] bytes = new byte [ size ]; new SecureRandom (). nextBytes ( bytes ); return bytes ; }","title":"Read/Write tag on ADF"},{"location":"seos-access-api-samples/reader-session.html","text":"","title":"Reader session"}]}